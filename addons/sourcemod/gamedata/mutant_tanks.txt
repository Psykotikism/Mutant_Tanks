"Games"
{
	"#default"
	{
		"#supported"
		{
			"game"		"left4dead"
			"game"		"left4dead2"
		}

		"Functions"
		{
			/**
			 * CAmmoDef::MaxCarry(int, CBaseCombatCharacter const*)
			 *
			 * Note: Detouring as a pre-hook for changing max magazine sizes.
			 **/
			"MTDetour_CAmmoDef::MaxCarry"
			{
				"signature"	"CAmmoDef::MaxCarry"
				"callconv"	"thiscall"
				"return"	"int"
				"this"		"address"
				"arguments"
				{
					"ammoType"
					{
						"type"		"int"
					}
					"player"
					{
						"type"		"cbaseentity"
					}
				}
			}

			/**
			 * CBaseCombatWeapon::GetMaxClip1()
			 *
			 * Note: Detouring as a pre-hook for changing max clip sizes.
			 **/
			"MTDetour_CBaseCombatWeapon::GetMaxClip1"
			{
				"signature"	"CBaseCombatWeapon::GetMaxClip1"
				"callconv"	"thiscall"
				"return"	"int"
				"this"		"entity"
			}

			/**
			 * CDeathFallCamera::Enable(CBasePlayer*)
			 *
			 * Note: Detouring as a pre-hook for disabling "death_fall_camera" entity per player.
			 **/
			"MTDetour_CDeathFallCamera::Enable"
			{
				"signature"	"CDeathFallCamera::Enable"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"player"
					{
						"type"		"cbaseentity"
					}
				}
			}

			/**
			 * CDirector::OnFirstSurvivorLeftSafeArea(CTerrorPlayer*)
			 *
			 * Note: Detouring as a post-hook for determining when to start the Tank wave spawner timer.
			 **/
			"MTDetour_CDirector::OnFirstSurvivorLeftSafeArea"
			{
				"signature"	"CDirector::OnFirstSurvivorLeftSafeArea"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"ignore"
				"arguments"
				{
					"survivor"
					{
						"type"		"cbaseentity"
					}
				}
			}

			/**
			 * CEnvRockLauncher::LaunchCurrentDir()
			 *
			 * Note: Detouring as a pre-hook for setting the Tank owner of rocks launched by "env_rock_launcher" entity.
			 **/
			"MTDetour_CEnvRockLauncher::LaunchCurrentDir"
			{
				"signature"	"CEnvRockLauncher::LaunchCurrentDir"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * CTankClaw::DoSwing()
			 *
			 * Note: Detouring as a pre-hook for patching "CTankClaw::SweepFist" to hit all survivors within range in "coop" modes.
			 * Note: Detouring as a post-hook for removing patch to hit all survivors within range in "coop" modes.
			 **/
			"MTDetour_CTankClaw::DoSwing"
			{
				"signature"	"CTankClaw::DoSwing"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * CTankClaw::GroundPound()
			 *
			 * Note: Detouring as a pre-hook for patching "CTankClaw::GroundPound" to hit all survivors within range in "coop" modes.
			 * Note: Detouring as a post-hook for removing patch to hit all survivors within range in "coop" modes.
			 **/
			"MTDetour_CTankClaw::GroundPound"
			{
				"signature"	"CTankClaw::GroundPound"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * CTankClaw::OnPlayerHit(CTerrorPlayer*, bool)
			 *
			 * Note: Detouring as a pre-hook for blocking Tank hits per player.
			 * Note: Detouring as a post-hook for lessening/cancelling Tank hit velocities per player.
			 **/
			"MTDetour_CTankClaw::OnPlayerHit"
			{
				"signature"	"CTankClaw::OnPlayerHit"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"player"
					{
						"type"		"cbaseentity"
					}
					"incap"
					{
						"type"		"bool"
					}
				}
			}

			/**
			 * CTerrorGameMovement::DoJump(Vector*)
			 *
			 * Note: Detouring as a pre-hook for patching max jump height per player.
			 * Note: Detouring as a post-hook for removing patch for max jump height.
			 **/
			"MTDetour_CTerrorGameMovement::DoJump"
			{
				"signature"	"CTerrorGameMovement::DoJump"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"address"
				"arguments"
				{
					"velocity"
					{
						"type"		"vectorptr"
					}
				}
			}

			/**
			 * CTerrorGun::Use(CBaseEntity *, CBaseEntity *, USE_TYPE, float)
			 *
			 * Note: Detouring as a pre-hook for patching weapon switches to secondary slots per player.
			 * Note: Detouring as a post-hook for removing patches for weapon switches to secondary slots.
			 **/
			"MTDetour_CTerrorGun::Use"
			{
				"signature"	"CTerrorGun::Use"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"player"
					{
						"type"		"cbaseentity"
					}
					"a2"
					{
						"type"		"cbaseentity"
					}
					"useType"
					{
						"type"		"int"
					}
					"a4"
					{
						"type"		"float"
					}
				}
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Detouring as a pre-hook for patching special infected kill effects per player.
			 * Note: Detouring as a post-hook for removing patches for special infected kill effects.
			 **/
			"MTDetour_CTerrorPlayer::Event_Killed"
			{
				"signature"	"CTerrorPlayer::Event_Killed"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"info"
					{
						"type"		"objectptr"
					}
				}
			}

			/**
			 * CTerrorPlayer::OnBeginChangeLevel(char const*)
			 *
			 * Note: Detouring as a pre-hook for ending each player's active rewards before transitioning.
			 **/
			"MTDetour_CTerrorPlayer::OnBeginChangeLevel"
			{
				"signature"	"CTerrorPlayer::OnBeginChangeLevel"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"targetMap"
					{
						"type"		"charptr"
					}
				}
			}

			/**
			 * CTerrorPlayer::OnEnterGhostState()
			 *
			 * Note: Detouring as a post-hook for force-spawning human-controlled Tanks in "coop" modes.
			 **/
			"MTDetour_CTerrorPlayer::OnEnterGhostState"
			{
				"signature"	"CTerrorPlayer::OnEnterGhostState"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * CTerrorPlayer::OnFalling()
			 *
			 * Note: Detouring as a pre-hook for catching falling survivors and patching fall scream cancellation.
			 * Note: Detouring as a post-hook for removing patch for fall scream cancellation.
			 **/
			"MTDetour_CTerrorPlayer::OnFalling"
			{
				"signature"	"CTerrorPlayer::OnFalling"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * CTerrorPlayer::OnIncapacitatedAsTank(CTakeDamageInfo const&)
			 *
			 * Note: Detouring as a pre-hook for changing "z_tank_incapacitated_health" per Tank before the dying animation starts.
			 * Note: Detouring as a post-hook for changing "z_tank_incapacitated_health" back to default value after the dying animation starts.
			 **/
			"MTDetour_CTerrorPlayer::OnIncapacitatedAsTank"
			{
				"signature"	"CTerrorPlayer::OnIncapacitatedAsTank"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"info"
					{
						"type"		"objectptr"
					}
				}
			}

			/**
			 * CTerrorPlayer::OnLadderDismount()
			 *
			 * Note: Detouring as a pre-hook for patching weapon deploy per player when getting off ladders.
			 * Note: Detouring as a post-hook for removing patch for weapon deploy when getting off ladders.
			 **/
			"MTDetour_CTerrorPlayer::OnLadderDismount"
			{
				"signature"	"CTerrorPlayer::OnLadderDismount"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * CTerrorPlayer::OnLadderMount()
			 *
			 * Note: Detouring as a pre-hook for patching weapon holster per player when getting on ladders.
			 * Note: Detouring as a post-hook for removing patch for weapon holster when getting on ladders.
			 **/
			"MTDetour_CTerrorPlayer::OnLadderMount"
			{
				"signature"	"CTerrorPlayer::OnLadderMount"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * CTerrorPlayer::OnRevived()
			 *
			 * Note: Detouring as a pre-hook for changing "survivor_revive_health" per player before reviving finishes.
			 * Note: Detouring as a post-hook for changing "survivor_revive_health" back to default value after reviving finishes.
			 **/
			"MTDetour_CTerrorPlayer::OnRevived"
			{
				"signature"	"CTerrorPlayer::OnRevived"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * CTerrorPlayer::OnShovedByPounceLanding(CTerrorPlayer*, bool)
			 *
			 * Note: Detouring as a pre-hook for blocking shoves per player via pounces.
			 **/
			"MTDetour_CTerrorPlayer::OnShovedByPounceLanding"
			{
				"signature"	"CTerrorPlayer::OnShovedByPounceLanding"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"attacker"
					{
						"type"		"cbaseentity"
					}
					"a2"
					{
						"type"		"bool"
					}
				}
			}

			/**
			 * CTerrorPlayer::OnShovedBySurvivor(CTerrorPlayer*, Vector const&)
			 *
			 * Note: Detouring as a pre-hook for blocking shoves per special infected via survivors.
			 **/
			"MTDetour_CTerrorPlayer::OnShovedBySurvivor"
			{
				"signature"	"CTerrorPlayer::OnShovedBySurvivor"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"player"
					{
						"type"		"cbaseentity"
					}
					"direction"
					{
						"type"		"vectorptr"
					}
				}
			}

			/**
			 * CTerrorPlayer::OnStaggered(CBaseEntity*, Vector const*)
			 *
			 * Note: Detouring as a pre-hook for blocking staggers per player.
			 **/
			"MTDetour_CTerrorPlayer::OnStaggered"
			{
				"signature"	"CTerrorPlayer::OnStaggered"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"charger"
					{
						"type"		"cbaseentity"
					}
					"origin"
					{
						"type"		"vectorptr"
					}
				}
			}

			/**
			 * CTerrorPlayer::OnVomitedUpon(CTerrorPlayer*, bool)
			 *
			 * Note: Detouring as a pre-hook for blocking Boomer vomits per player.
			 **/
			"MTDetour_CTerrorPlayer::OnVomitedUpon"
			{
				"signature"	"CTerrorPlayer::OnVomitedUpon"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"boomer"
					{
						"type"		"cbaseentity"
					}
					"explosion"
					{
						"type"		"bool"
					}
				}
			}

			/**
			 * CTerrorPlayer::PreThink()
			 *
			 * Note: Detouring as a pre-hook for patching auto-dismount per player when shooting while on ladders.
			 * Note: Detouring as a post-hook for removing patch for auto-dismount when shooting while on ladders.
			 **/
			"MTDetour_CTerrorPlayer::PreThink"
			{
				"signature"	"CTerrorPlayer::PreThink"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * CTerrorPlayer::StartReviving(CTerrorPlayer*)
			 *
			 * Note: Detouring as a pre-hook for changing "survivor_revive_duration" per player before reviving someone.
			 * Note: Detouring as a post-hook for changing "survivor_revive_duration" back to default value after reviving starts.
			 **/
			"MTDetour_CTerrorPlayer::StartReviving"
			{
				"signature"	"CTerrorPlayer::StartReviving"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"target"
					{
						"type"		"cbaseentity"
					}
				}
			}

			/**
			 * CTerrorWeapon::CanDeploy()
			 *
			 * Note: Detouring as a pre-hook for patching move type per player while on ladders.
			 * Note: Detouring as a post-hook for removing patch for move type while on ladders.
			 **/
			"MTDetour_CTerrorWeapon::CanDeployFor"
			{
				"signature"	"CTerrorWeapon::CanDeployFor"
				"callconv"	"thiscall"
				"return"	"bool"
				"this"		"entity"
			}

			/**
			 * CTerrorWeapon::SecondaryAttack()
			 *
			 * Note: Detouring as a pre-hook for changing "z_gun_swing_interval" per player before shoving.
			 * Note: Detouring as a post-hook for changing "z_gun_swing_interval" back to default value after shoving.
			 **/
			"MTDetour_CTerrorWeapon::SecondaryAttack"
			{
				"signature"	"CTerrorWeapon::SecondaryAttack"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * CWeaponSpawn::Use(CBaseEntity *, CBaseEntity *, USE_TYPE, float)
			 *
			 * Note: Detouring as a pre-hook for patching weapon switches to secondary slots per player.
			 * Note: Detouring as a post-hook for removing patches for weapon switches to secondary slots.
			 **/
			"MTDetour_CWeaponSpawn::Use"
			{
				"signature"	"CWeaponSpawn::Use"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"player"
					{
						"type"		"cbaseentity"
					}
					"a2"
					{
						"type"		"cbaseentity"
					}
					"useType"
					{
						"type"		"int"
					}
					"a4"
					{
						"type"		"float"
					}
				}
			}

			/**
			 * PassServerEntityFilter(IHandleEntity const*, IHandleEntity const*)
			 *
			 * Note: Detouring as a pre-hook for checking entity collision.
			 * Note: Detouring as a post-hook for checking entity collision.
			 **/
			"MTDetour_PassServerEntityFilter"
			{
				"signature"	"PassServerEntityFilter"
				"callconv"	"cdecl"
				"return"	"bool"
				"this"		"ignore"
				"arguments"
				{
					"entity1"
					{
						"type"		"int"
					}
					"entity2"
					{
						"type"		"int"
					}
				}
			}

			/**
			 * Tank::EnterStasis()
			 *
			 * Note: Detouring as a post-hook for checking when a Tank enters stasis mode.
			 **/
			"MTDetour_Tank::EnterStasis"
			{
				"signature"	"Tank::EnterStasis"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * Tank::LeaveStasis()
			 *
			 * Note: Detouring as a post-hook for checking when a Tank leaves stasis mode.
			 **/
			"MTDetour_Tank::LeaveStasis"
			{
				"signature"	"Tank::LeaveStasis"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * ZombieManager::ReplaceTank(CTerrorPlayer*, CTerrorPlayer*)
			 *
			 * Note: Detouring as a post-hook for catching Tank passes.
			 **/
			"MTDetour_ZombieManager::ReplaceTank"
			{
				"signature"	"ZombieManager::ReplaceTank"
				"callconv"	"thiscall"
				"return"	"int"
				"this"		"ignore"
				"arguments"
				{
					"oldTank"
					{
						"type"		"cbaseentity"
					}
					"newTank"
					{
						"type"		"cbaseentity"
					}
				}
			}

			/**
			 * ZombieManager::SpawnTank(Vector const&, QAngle const&)
			 *
			 * Note: Detouring as a pre-hook for determining when to allow/block Tank spawns.
			 **/
			"MTDetour_ZombieManager::SpawnTank"
			{
				"signature"	"ZombieManager::SpawnTank"
				"callconv"	"thiscall"
				"return"	"int"
				"this"		"ignore"
				"arguments"
				{
					"origin"
					{
						"type"		"vectorptr"
					}
					"angles"
					{
						"type"		"vectorptr"
					}
				}
			}
		}

		"Addresses"
		{
			/**
			 * CTerrorWeapon::CanDeployFor(CTerrorPlayer*)
			 *
			 * Note: Uses the signature for "CTerrorWeapon::CanDeployFor" to find the address.
			 **/
			"CanDeployForStart"
			{
				"signature"	"CTerrorWeapon::CanDeployFor"
			}

			/**
			 * CTerrorGameMovement::DoJump(Vector*)
			 *
			 * Note: Uses the signature for "CTerrorGameMovement::DoJump" to find the address.
			 **/
			"DoJumpStart"
			{
				"signature"	"CTerrorGameMovement::DoJump"
			}

			/**
			 * This is the initial method for finding the default jump height (57.0) using its byte signature.
			 * If this method fails, the plugin will rely on the "DoJumpValueRead" method instead.
			 **/
			"DoJumpValueBytes"
			{
				"signature"	"CTerrorGameMovement::DoJump::Value"
			}

			/**
			 * CTerrorGun::EquipSecondWeapon()
			 *
			 * Note: Uses the signature for "CTerrorGun::EquipSecondWeapon" to find the address.
			 **/
			"EquipSecondWeaponStart"
			{
				"signature"	"CTerrorGun::EquipSecondWeapon"
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Uses the signature for "CTerrorPlayer::Event_Killed" to find the address.
			 **/
			"Event_KilledStart"
			{
				"signature"	"CTerrorPlayer::Event_Killed"
			}

			/**
			 * CSmokeCloudSystem::FireGameEvent(IGameEvent *)
			 *
			 * Note: Uses the signature for "CSmokeCloudSystem::FireGameEvent" to find the address.
			 **/
			"FireSmokerCloud"
			{
				"signature"	"CSmokeCloudSystem::FireGameEvent"
			}

			/**
			 * CTankClaw::GroundPound()
			 *
			 * Note: Uses the signature for "CTankClaw::GroundPound" to find the address.
			 **/
			"GroundPoundStart"
			{
				"signature"	"CTankClaw::GroundPound"
			}

			/**
			 * CTerrorPlayer::OnFalling()
			 *
			 * Note: Uses the signature for "CTerrorPlayer::OnFalling" to find the address.
			 **/
			"OnFallingStart"
			{
				"signature"	"CTerrorPlayer::OnFalling"
			}

			/**
			 * CTerrorPlayer::OnLadderDismount()
			 *
			 * Note: Uses the signature for "CTerrorPlayer::OnLadderDismount" to find the address.
			 **/
			"OnLadderDismountStart"
			{
				"signature"	"CTerrorPlayer::OnLadderDismount"
			}

			/**
			 * CTerrorPlayer::OnLadderMount()
			 *
			 * Note: Uses the signature for "CTerrorPlayer::OnLadderMount" to find the address.
			 **/
			"OnLadderMountStart"
			{
				"signature"	"CTerrorPlayer::OnLadderMount"
			}

			/**
			 * CTankRock::OnRelease(Vector const&, QAngle const&, Vector const&, Vector const&)
			 *
			 * Note: Uses the signature for "CTankRock::OnRelease" to find the address.
			 **/
			"OnReleaseStart"
			{
				"signature"	"CTankRock::OnRelease"
			}

			/**
			 * CTerrorPlayer::OnTakeDamage_Alive(CTakeDamageInfo const&)
			 *
			 * Note: Uses the signature for "CTerrorPlayer::OnTakeDamage_Alive" to find the address.
			 **/
			"OnTakeDamageAliveStart"
			{
				"signature"	"CTerrorPlayer::OnTakeDamage_Alive"
			}

			/**
			 * CTerrorPlayer::PreThink()
			 *
			 * Note: Uses the signature for "CTerrorPlayer::PreThink" to find the address.
			 **/
			"PreThinkStart"
			{
				"signature"	"CTerrorPlayer::PreThink"
			}

			/**
			 * CTerrorPlayer::RoundRespawn()
			 *
			 * Note: Uses the signature for "CTerrorPlayer::RoundRespawn" to find the address.
			 **/
			"RoundRespawnStart"
			{
				"signature"	"CTerrorPlayer::RoundRespawn"
			}

			/**
			 * CTankClaw::SweepFist(Vector const&, Vector const&)
			 *
			 * Note: Uses the signature for "CTankClaw::SweepFist" to find the address.
			 **/
			"SweepFistStart"
			{
				"signature"	"CTankClaw::SweepFist"
			}
		}

		"Offsets"
		{
			/**
			 * Only Windows and Linux servers are supported.
			 **/
			"OS"
			{
				"linux"		"1"
				"windows"	"0"
			}

			/**
			 * Action<Tank>::FirstContainedResponder()
			 *
			 * How to find:
			 * 1. Use asherkin's VTable dump.
			 **/
			"Action<Tank>::FirstContainedResponder"
			{
				"linux"		"2"
				"windows"	"1"
			}

			/**
			 * CBaseEntity::GetRefEHandle()
			 *
			 * How to find:
			 * 1. Use asherkin's VTable dump.
			 **/
			"CBaseEntity::GetRefEHandle"
			{
				"linux"		"3"
				"windows"	"2"
			}
		}

		"Signatures"
		{
			/**
			 * Linux has symbols so the plugin can just directly access the Director's address via its symbol.
			 **/
			"TheDirector"
			{
				"library"	"server"
				"linux"		"@TheDirector"
			}
		}
	}

	"left4dead"
	{
		"Functions"
		{
			/**
			 * CFirstAidKit::FinishHealing()
			 *
			 * Note: Detouring as a pre-hook for changing "first_aid_heal_percent" per player before healing finishes.
			 * Note: Detouring as a post-hook for changing "first_aid_heal_percent" back to default value after healing finishes.
			 **/
			"MTDetour_CFirstAidKit::FinishHealing"
			{
				"signature"	"CFirstAidKit::FinishHealing"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * CFirstAidKit::StartHealing(CFirstAidKit::HealTargetType)
			 *
			 * Note: Detouring as a pre-hook for changing "first_aid_kit_use_duration" per player before healing starts.
			 * Note: Detouring as a post-hook for changing "first_aid_kit_use_duration" back to default value after healing starts.
			 * Note for Linux users: Function prototype uses custom registers including the "this" pointer which needs to be registered as param 1.
			 **/
			"MTDetour_CFirstAidKit::StartHealing"
			{
				"signature"	"CFirstAidKit::StartHealing"
				"linux"
				{
					"callconv"	"cdecl"
					"return"	"void"
					"this"		"ignore"
					"arguments"
					{
						"this"
						{
							"type"		"cbaseentity"
							"register"	"eax"
						}
						"targetType"
						{
							"type"		"int"
							"register"	"edx"
						}
					}
				}
				"windows"
				{
					"callconv"	"thiscall"
					"return"	"void"
					"this"		"entity"
					"arguments"
					{
						"targetType"
						{
							"type"		"int"
						}
					}
				}
			}

			/**
			 * CBaseEntity::Create(char const*, Vector const&, QAngle const&, CBaseEntity*)
			 *
			 * Note: Detouring as a post-hook for setting Tank rock colors after they are spawned by "env_rock_launcher" entity.
			 * Note for Linux users: The "CTankRock::Create" function was previously used but it was causing crashes due to custom registers.
			 **/
			"MTDetour_CBaseEntity::Create"
			{
				"signature"	"CBaseEntity::Create"
				"callconv"	"cdecl"
				"return"	"cbaseentity"
				"arguments"
				{
					"classname"
					{
						"type"		"charptr"
					}
					"origin"
					{
						"type"		"vectorptr"
					}
					"angles"
					{
						"type"		"vectorptr"
					}
					"owner"
					{
						"type"		"cbaseentity"
					}
				}
			}

			/**
			 * CTerrorPlayer::OnBeginChangeLevel(char const*, KeyValues *)
			 *
			 * Note: Detouring as a pre-hook for ending each player's active rewards before transitioning.
			 * Note: L4D1 has a second param.
			 **/
			"MTDetour_CTerrorPlayer::OnBeginChangeLevel"
			{
				"signature"	"CTerrorPlayer::OnBeginChangeLevel"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"kvPointer"
					{
						"type"		"int"
					}
				}
			}

			/**
			 * CTerrorPlayer::OnVomitedUpon(CTerrorPlayer*, bool, bool)
			 *
			 * Note: Detouring as a pre-hook for blocking Boomer vomits per player.
			 * Note: L4D1 has a third param.
			 **/
			"MTDetour_CTerrorPlayer::OnVomitedUpon"
			{
				"arguments"
				{
					"a3"
					{
						"type"		"bool"
					}
				}
			}

			/**
			 * CTerrorPlayer::SetMainActivity(Activity, bool)
			 *
			 * Note: Detouring as a pre-hook for skipping animations after Tank hits per player for faster recovery.
			 **/
			"MTDetour_CTerrorPlayer::SetMainActivity"
			{
				"signature"	"CTerrorPlayer::SetMainActivity"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"activity"
					{
						"type"		"int"
					}
					"a2"
					{
						"type"		"bool"
					}
				}
			}
		}

		"Addresses"
		{
			/**
			 * Windows: Uses an offset of "SurvivorLegsMeetRescueVehicleArrival::Update" to get the Director's address.
			 * Linux: Uses a symbol pointing to the Director's address.
			 **/
			"CDirector"
			{
				"linux"
				{
					"signature"	"TheDirector"
				}
				"windows"
				{
					"signature"	"SurvivorLegsMeetRescueVehicleArrival::Update"
					"offset"	"9"
				}
			}

			/**
			 * This is the failsafe method for finding the default jump height (57.0) by jumping to its location.
			 * If the "DoJumpValueBytes" method fails, the plugin will rely on this method instead.
			 *
			 * Note: This method only works on Windows since on Linux it just points to the offset's address not the value's actual address.
			 **/
			"DoJumpValueRead"
			{
				"signature"	"CTerrorGameMovement::DoJump"
				"windows"
				{
					"offset"	"174"
				}
			}

			/**
			 * InfectedExecAction::OnInjured(Infected *, CTakeDamageInfo const&)
			 *
			 * Note: Uses the signature for "InfectedExecAction::OnInjured" to find the address.
			 **/
			"OnInjuredStart"
			{
				"signature"	"InfectedExecAction::OnInjured"
			}

			/**
			 * PlayerLocomotion::GetMaxJumpHeight()
			 *
			 * Note: Uses the signature for "PlayerLocomotion::GetMaxJumpHeight" to find the address.
			 **/
			"GetMaxJumpHeightStart"
			{
				"linux"
				{
					"signature"	"PlayerLocomotion::GetMaxJumpHeight"
				}
			}
		}

		"Offsets"
		{
			/**
			 * CBaseCombatWeapon::GetMaxClip1()
			 *
			 * How to find:
			 * 1. Use asherkin's VTable dump.
			 **/
			"CBaseCombatWeapon::GetMaxClip1"
			{
				"linux"		"301"
				"windows"	"300"
			}

			/**
			 * CTankClaw::GroundPound()
			 *
			 * Note: Patches the "IsVersusMode" check.
			 *
			 * How to find on Windows:
			 * 1. Look in the "CTankClaw::GroundPound" function for a variable assigned to another variable right below a funtion call to "CBaseEntity::GetTeamNumber".
			 * 2. Verify that it starts with "74" and is 2 bytes long.
			 * 3. Verify that the next line starts with "80" and is 5 bytes long.
			 * 4. Verify that the next line starts with "74" and is 2 bytes long.
			 *
			 * How to find on Linux:
			 * 1. Look in the "CTankClaw::GroundPound" function for a variable that stores the return value of "IsVersusMode".
			 * 2. Verify that it starts with "E8" and is 5 bytes long.
			 * 3. Verify that the next line starts with "84" and is 2 bytes long.
			 **/
			"CTankClaw::GroundPound::Check"
			{
				"linux"		"1043" // start at E8 and patch 7 bytes with NOPs (0x90)
				"windows"	"761" // start at 74 and patch 9 bytes with NOPs (0x90)
			}

			/**
			 * CTankClaw::SweepFist(Vector const&, Vector const&)
			 *
			 * Note: Patches the "IsVersusMode" check.
			 *
			 * How to find:
			 * 1. Look in the "CTankClaw::SweepFist" function for a condition that validates "IsVersusMode" or "IsHoldoutMode".
			 * 2. Verify that it starts with "E8" and is 5 bytes long.
			 * 3. The instruction should look like a function call.
			 **/
			"CTankClaw::SweepFist::Check1"
			{
				"linux"		"1051" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"1067" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTankClaw::SweepFist(Vector const&, Vector const&)
			 *
			 * Note: Patches the "IsHoldoutMode" check.
			 *
			 * How to find:
			 * 1. Look in the "CTankClaw::SweepFist" function for a condition that validates "IsVersusMode" or "IsHoldoutMode".
			 * 2. Verify that it starts with "E8" and is 5 bytes long.
			 * 3. The instruction should look like a function call.
			 **/
			"CTankClaw::SweepFist::Check2"
			{
				"linux"		"3418" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"1076" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTankRock::OnRelease(Vector const&, QAngle const&, Vector const&, Vector const&)
			 *
			 * Note: Patches the "CBaseEntity::EmitSound" call for "HulkZombie.Throw.FlyLoop".
			 *
			 * How to find on Windows:
			 * 1. Locate the "HulkZombie.Throw.FlyLoop" string.
			 * 2. The instruction should look like a function call.
			 * 3. Look for the 2-byte float (FLDZ) instruction right before a PUSH instruction above that function call.
			 * 4. The length of the JMP instruction patch will be determined by the following equation:
			 * Let a1 = Address of the patch location + five bytes (because the patch itself takes five bytes)
			 * Let a2 = Address of the start of the setup for the "CBaseEntity::ThinkSet" call
			 * Equation: a2 - a1 = JMP instruction length
			 *
			 * How to find on Linux:
			 * 1. Locate the "HulkZombie.Throw.FlyLoop" string.
			 * 2. The instruction should look like a function call.
			 **/
			"CTankRock::OnRelease::SoundLoop"
			{
				"linux"		"182" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"117" // start at D9 and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
			}

			/**
			 * CTerrorGun::EquipSecondWeapon()
			 *
			 * Note: Patches the "CTerrorGun::Deploy" function call.
			 *
			 * How to find:
			 * 1. Look for the fourth "CBaseCombatCharacter::GetActiveWeapon" function call.
			 * 2. The call instruction below that should be the start of the "CTerrorGun::Holster" function call.
			 * 3. The call instruction below that should be the start of the "CBaseCombatCharacter::SetActiveWeapon" function call.
			 * 4. The call instruction below that should be the start of the "CTerrorGun::Deploy" function call.
			 * Let a1 = Address of the patch location + five bytes (because the patch itself takes five bytes)
			 * Let a2 = Address of the start of the instruction after the "CTerrorGun::Deploy" call instruction
			 * Equation: a2 - a1 = JMP instruction length
			 **/
			"CTerrorGun::EquipSecondWeapon::Deploy"
			{
				"linux"		"332" // start at 8B and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
				"windows"	"425" // start at 8B and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
			}

			/**
			 * CTerrorGun::EquipSecondWeapon()
			 *
			 * Note: Patches the "CTerrorGun::Holster" function call.
			 *
			 * How to find:
			 * 1. Look for the fourth "CBaseCombatCharacter::GetActiveWeapon" function call.
			 * 2. The call instruction below that should be the start of the "CTerrorGun::Holster" function call.
			 * Let a1 = Address of the patch location + five bytes (because the patch itself takes five bytes)
			 * Let a2 = Address of the start of the instruction after the "CTerrorGun::Holster" call instruction
			 * Equation: a2 - a1 = JMP instruction length
			 **/
			"CTerrorGun::EquipSecondWeapon::Holster"
			{
				"linux"		"297" // start at 8B and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
				"windows"	"403" // start at 8B and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
			}

			/**
			 * CTerrorGun::EquipSecondWeapon()
			 *
			 * Note: Patches the "CBaseCombatCharacter::SetActiveWeapon" function call.
			 *
			 * How to find:
			 * 1. Look for the fourth "CBaseCombatCharacter::GetActiveWeapon" function call.
			 * 2. The call instruction below that should be the start of the "CTerrorGun::Holster" function call.
			 * 3. The call instruction below that should be the start of the "CBaseCombatCharacter::SetActiveWeapon" function call.
			 * Let a1 = Address of the patch location + five bytes (because the patch itself takes five bytes)
			 * Let a2 = Address of the start of the instruction after the "CBaseCombatCharacter::SetActiveWeapon" call instruction
			 * Equation: a2 - a1 = JMP instruction length
			 **/
			"CTerrorGun::EquipSecondWeapon::SetActiveWeapon"
			{
				"linux"		"316" // start at 89 and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
				"windows"	"417" // start at 56 and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
			}

			/**
			 * CTerrorPlayer::Deafen(float, float, float)
			 *
			 * How to find:
			 * 1. Use asherkin's VTable dump.
			 **/
			"CTerrorPlayer::Deafen"
			{
				"linux"		"494"
				"windows"	"491"
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: This is the offset for the "m_hAttacker" member variable in the "CTakeDamageInfo" class.
			 *
			 * How to find:
			 * 1. Look in the alliedmodders/hl2sdk-l4d "takedamageinfo.h" file.
			 * 2. Each member variable takes up 4 bytes for each of its cells (12 bytes for floats).
			 **/
			"CTerrorPlayer::Event_Killed::Attacker"
			{
				"linux"		"40"
				"windows"	"40"
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "DispatchParticleEffect" call for "boomer_explode".
			 *
			 * How to find:
			 * 1. Locate the "boomer_explode" string.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Boomer1" // "boomer_explode"
			{
				"linux"		"7186" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"5114" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "CBaseEntity::EmitSound" call for "BoomerZombie.Detonate".
			 *
			 * How to find:
			 * 1. Locate the "BoomerZombie.Detonate" string.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Boomer2" // "BoomerZombie.Detonate"
			{
				"linux"		"7220" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"5137" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "CreateExplosion" call.
			 *
			 * How to find:
			 * 1. Locate the "boomer_exploded" string.
			 * 2. The function is located in the previous code block above that function call.
			 * 3. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Boomer3" // CreateExplosion
			{
				"linux"		"5752" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"5255" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "CBaseEntity::EmitSound" call for "SmokerZombie.Explode".
			 * Note for Windows users: The server crashes when patching 5 bytes with NOPs (0x90), so do a jump (JMP) instruction instead.
			 *
			 * How to find:
			 * 1. Locate the "SmokerZombie.Explode" string.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Smoker1" // "SmokerZombie.Explode"
			{
				"linux"		"7366" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"5502" // start at D9 and patch 2 bytes with EB ??
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "DispatchParticleEffect" call for "smoker_smokecloud".
			 *
			 * How to find:
			 * 1. Locate the "smoker_smokecloud" string.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Smoker2" // "smoker_smokecloud"
			{
				"linux"		"7529" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"5578" // start at 8B and patch 2 bytes with EB ??
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "DispatchParticleEffect" call for "smoker_smokecloud_camera".
			 *
			 * How to find:
			 * 1. Locate the "smoker_smokecloud_camera" string.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Smoker3" // "smoker_smokecloud_camera"
			{
				"linux"		"7712" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"5766" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::GetFlowDistance(CNavArea const*)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 * 5. Look for the 7-byte float (FLD) instruction.
			 * 6. The offset at the very end of that line of code is the offset for "m_flow".
			 *
			 * How to find on Linux:
			 * 1. Locate the function.
			 * 2. Look for the 7-byte float (FLD) instruction.
			 * 3. The offset at the very end of that line of code is the offset for "m_flow".
			 **/
			"CTerrorPlayer::GetFlowDistance::m_flow"
			{
				"linux"		"348"
				"windows"	"340"
			}

			/**
			 * CTerrorPlayer::GetLastKnownArea()
			 *
			 * How to find:
			 * 1. Use asherkin's VTable dump.
			 **/
			"CTerrorPlayer::GetLastKnownArea"
			{
				"linux"		"310"
				"windows"	"309"
			}

			/**
			 * CTerrorPlayer::OnFalling()
			 *
			 * Note: Patches the "CBaseEntity::EmitTrackedSound" call for "Player.Fall".
			 *
			 * How to find on Windows:
			 * 1. Locate the "Player.Fall" string.
			 * 2. The instruction should look like a function call.
			 * 3. Look for the 6-byte float (FLD) instruction right before a PUSH instruction above that function call.
			 * 4. The length of the JMP instruction patch will be determined by the following equation:
			 * Let a1 = Address of the patch location + five bytes (because the patch itself takes five bytes)
			 * Let a2 = Address of the start of the setup for the 2-byte JMP instruction
			 * Equation: a2 - a1 = JMP instruction length
			 *
			 * How to find on Linux:
			 * 1. Locate the "Player.Fall" string.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::OnFalling::Scream"
			{
				"linux"		"397" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"611" // start at D9 and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
			}

			/**
			 * CTerrorPlayer::OnLadderDismount()
			 *
			 * Note: Patches weapon deploy logic.
			 *
			 * How to find:
			 * 1. Locate the second call to "CBaseCombatCharacter::GetActiveWeapon".
			 * 2. The patch location is at the line of code below that function call.
			 **/
			"CTerrorPlayer::OnLadderDismount::WeaponDeploy"
			{
				"linux"		"61" // start at 8B and patch 11 bytes with NOPs (0x90)
				"windows"	"41" // start at FF and patch 2 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::OnLadderMount()
			 *
			 * Note: Patches weapon holster logic.
			 *
			 * How to find:
			 * 1. Look for the team check.
			 * 2. The patch location should be a jump (JZ/JNZ) instruction.
			 **/
			"CTerrorPlayer::OnLadderMount::WeaponHolster"
			{
				"linux"		"73" // start at 74 and patch 2 bytes with NOPs (0x90)
				"windows"	"39" // start at 75 and patch 2 bytes with POP (0x5E) and RET (0xC3)
			}

			/**
			 * CTerrorPlayer::OnTakeDamage_Alive(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "CTerrorPlayer::StopBeingRevived" function call.
			 *
			 * How to find on Windows:
			 * 1. Find a 2-byte instruction that pushes a "1" to a function call.
			 * 2. The function call that the "1" is being passed to is the patch location.
			 *
			 * How to find on Linux:
			 * 1. Find an 8-byte instruction that moves a bool value to a function call.
			 * 2. The function call that the bool value is being passed to is the patch location.
			 **/
			"CTerrorPlayer::OnTakeDamage_Alive::Revive"
			{
				"linux"		"2247" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"1775" // start at 6A and patch 9 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::PreThink()
			 *
			 * Note: Patches the safe drop logic.
			 *
			 * How to find:
			 * 1. Look for a compare (CMP) instruction that compares a value to "9".
			 * 2. Get the offset of the last byte.
			 **/
			"CTerrorPlayer::PreThink::SafeDropLogic"
			{
				"linux"		"161" // start at 09 and patch 1 byte with CALL (0xFF)
				"windows"	"470" // start at 09 and patch 1 byte with CALL (0xFF)
			}

			/**
			 * CTerrorPlayer::RoundRespawn()
			 *
			 * Note: Patches the stats reset function.
			 *
			 * How to find:
			 * 1. Look for a jump (JNZ) instruction.
			 * 2. That is the patch location.
			 **/
			"CTerrorPlayer::RoundRespawn::StatsCondition"
			{
				"linux"		"35" // start at 75 and patch 1 byte with JNS (0x79)
				"windows"	"15" // start at 75 and patch 1 byte with JNS (0x79)
			}

			/**
			 * InfectedExecAction::OnInjured(Infected *, CTakeDamageInfo const&)
			 *
			 * Note: Patches the damage check to trigger hollow point ammo.
			 *
			 * How to find on Windows:
			 * 1. Look for the team check.
			 * 2. Look for an if statement inside that team check's code block.
			 * 3. The first function in that if statement is the target function to patch.
			 * 4. The patch starts at the PUSH instruction that pushes an offset to the function call.
			 *
			 * How to find on Linux:
			 * 1. Find a 7-byte instruction that tests an offset before doing a jump (JZ) instruction.
			 * 2. The patch location should be a TEST instruction that is a few instructions above the "CTerrorPlayer::GetMinigun" function call.
			 **/
			"InfectedExecAction::OnInjured::Requirement"
			{
				"linux"		"795" // start at F6 and patch 7 bytes with a different instruction
				"windows"	"147" // start at 6A and patch 11 bytes with a different instruction
			}

			/**
			 * CTerrorWeapon::CanDeploy()
			 *
			 * Note: Patches the move type logic.
			 *
			 * How to find:
			 * 1. Look for a compare (CMP) instruction that compares a value to "9".
			 * 2. Get the offset of the last byte.
			 **/
			"CTerrorWeapon::CanDeployFor::MoveType"
			{
				"linux"		"143" // start at 09 and patch 1 byte with CALL (0xFF)
				"windows"	"140" // start at 09 and patch 1 byte with CALL (0xFF)
			}

			/**
			 * PlayerLocomotion::GetMaxJumpHeight()
			 *
			 * Note for Windows users: This isn't required.
			 *
			 * How to find:
			 * 1. Look at the instructions for "PlayerLocomotion::GetMaxJumpHeight".
			 * 2. Find the instruction that adds an offset before pushing "57.0" value.
			 * 3. Get the offset of the third byte.
			 **/
			"PlayerLocomotion::GetMaxJumpHeight::Add"
			{
				"linux"		"7"
			}

			/**
			 * PlayerLocomotion::GetMaxJumpHeight()
			 *
			 * Note for Windows users: This isn't required.
			 *
			 * How to find:
			 * 1. Look at the instructions for "PlayerLocomotion::GetMaxJumpHeight".
			 * 2. Find the instruction that adds an offset before pushing "57.0" value.
			 **/
			"PlayerLocomotion::GetMaxJumpHeight::Call"
			{
				"linux"		"5"
			}

			/**
			 * PlayerLocomotion::GetMaxJumpHeight()
			 *
			 * Note for Windows users: This isn't required.
			 *
			 * How to find:
			 * 1. Look at the instructions for "PlayerLocomotion::GetMaxJumpHeight".
			 * 2. Find the instruction that pushes the "57.0" value.
			 * 3. Get the offset of the third byte.
			 **/
			"PlayerLocomotion::GetMaxJumpHeight::Value"
			{
				"linux"		"13"
			}

			/**
			 * Tank::GetIntentionInterface()
			 *
			 * How to find:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2a. Use IDA to get the VTable dump for the "Tank" class on Windows.
			 * 2b. Use IDA to get the VTable dump for the "Tank" class on Linux.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4a. Look for the target function in the Windows binary.
			 * 4b. Look for the target function in the Linux binary.
			 * 5. Multiply the member variable offset by 4.
			 **/
			"Tank::GetIntentionInterface"
			{
				"linux"		"11940"
				"windows"	"11924"
			}

			/**
			 * TankIdle::GetName()
			 *
			 * How to find:
			 * 1. Use asherkin's VTable dump.
			 **/
			"TankIdle::GetName"
			{
				"linux"		"36"
				"windows"	"35"
			}

			/**
			 * WitchLocomotion::IsAreaTraversable(CNavArea const*)
			 *
			 * How to find:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2a. Use IDA to get the VTable dump for the "WitchLocomotion" class on Windows.
			 * 2b. Use IDA to get the VTable dump for the "WitchLocomotion" class on Linux.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4a. Look for the target function in the Windows binary.
			 * 4b. Look for the target function in the Linux binary.
			 * 5. Look for the first 10-byte TEST instruction.
			 * 6. The offset in that instruction is the offset for "m_attributeFlags".
			 **/
			"WitchLocomotion::IsAreaTraversable::m_attributeFlags"
			{
				"linux"		"304"
				"windows"	"300"
			}
		}

		"Signatures"
		{
			/**
			 * CAmmoDef::MaxCarry(int, CBaseCombatCharacter const*)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CAmmoDef" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CAmmoDef::MaxCarry"
			{
				"library"	"server"
				"linux"		"@_ZN8CAmmoDef8MaxCarryEiPK20CBaseCombatCharacter"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x7C\x2A\x3B\x2A\x2A\x7D\x2A\x6B\x2A\x2A\x03\x2A\x8B\x2A\x2A\x83\x2A\x2A\x75\x2A\x8B\x2A\x2A\x85\x2A\x74\x2A\x8B\x2A\x2A\x8B\x2A\x2A\xC2"
						/* ? ? ? ? ? ? ? 7C ? 3B ? ? 7D ? 6B ? ? 03 ? 8B ? ? 83 ? ? 75 ? 8B ? ? 85 ? 74 ? 8B ? ? 8B ? ? C2 */
			}

			/**
			 * CBaseCombatWeapon::GetMaxClip1()
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CBaseCombatWeapon" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CBaseCombatWeapon::GetMaxClip1"
			{
				"library"	"server"
				"linux"		"@_ZNK17CBaseCombatWeapon11GetMaxClip1Ev"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x50\xE8\x2A\x2A\x2A\x2A\x8B\x80\x60"
						/* ? ? ? ? ? ? ? 50 E8 ? ? ? ? 8B 80 60 */
			}

			/**
			 * CBaseEntity::Create(char const*, Vector const&, QAngle const&, CBaseEntity*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "tank_rock" string.
			 * 2. One of the functions that references that string is "CTankRock::Create".
			 * 3. The first function call inside "CTankRock::Create" should be this function.
			 **/
			"CBaseEntity::Create"
			{
				"library"	"server"
				"linux"		"@_ZN11CBaseEntity6CreateEPKcRK6VectorRK6QAnglePS_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x6A\x2A\x50\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x83\x2A\x2A\x85\x2A\x75\x2A\x56"
						/* ? ? ? ? ? ? ? 6A ? 50 E8 ? ? ? ? 8B ? 83 ? ? 85 ? 75 ? 56 */
			}

			/**
			 * CDeathFallCamera::Enable(CBasePlayer*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "SurvivorStandingOnCar" string.
			 * 2. The string can only be found in "CTerrorPlayer::OnGroundChanged".
			 * 3. Look for the "point_deathfall_camera" string in "CTerrorPlayer::OnGroundChanged".
			 * 4. The first function call after that string's reference should be "CBasePlayer::ClearZoomOwner".
			 * 5. One of the functions that calls "CBasePlayer::ClearZoomOwner" should be this function.
			 **/
			"CDeathFallCamera::Enable"
			{
				"library"	"server"
				"linux"		"@_ZN16CDeathFallCamera6EnableEP11CBasePlayer"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x85\x2A\x74\x2A\x6A"
						/* ? ? ? ? ? ? 8B ? 8B ? E8 ? ? ? ? 85 ? 74 ? 6A */
			}

			/**
			 * Director::HasAnySurvivorLeftSafeArea()
			 *
			 * How to find on Windows:
			 * 1. Search for the "I've walked out of the checkpoint" string.
			 * 2. The first function call below the string should be this function.
			 **/
			"CDirector::HasAnySurvivorLeftSafeArea"
			{
				"library"	"server"
				"linux"		"@_ZN8Director26HasAnySurvivorLeftSafeAreaEv"
				"windows"	"\x8A\x2A\x68\x01\x00\x00\xC3"
						/* 8A ? 68 01 00 00 C3 */
			}

			/**
			 * Director::OnFirstSurvivorLeftSafeArea(CTerrorPlayer*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "Allowing spawning - %s left safe area\n" string.
			 * 2. The string can only be found in this function.
			 **/
			"CDirector::OnFirstSurvivorLeftSafeArea"
			{
				"library"	"server"
				"linux"		"@_ZN8Director27OnFirstSurvivorLeftSafeAreaEP13CTerrorPlayer"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x56\x8B\x2A\x80\xBE\x2A\x2A\x2A\x2A\x2A\x75\x2A\x80\x3D"
						/* ? ? ? ? ? ? ? ? 56 8B ? 80 BE ? ? ? ? ? 75 ? 80 3D */
			}

			/**
			 * CEnvRockLauncher::LaunchCurrentDir()
			 *
			 * How to find on Windows:
			 * 1. Search for the "tank_rock" string.
			 * 2. One of the functions that references that string is "CTankRock::Create".
			 * 3. One of the functions that calls "CTankRock::Create" should be this function.
			 **/
			"CEnvRockLauncher::LaunchCurrentDir"
			{
				"library"	"server"
				"linux"		"@_ZN16CEnvRockLauncher16LaunchCurrentDirEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x86\x2A\x2A\x2A\x2A\xC1\x2A\x2A\xA8\x2A\x57\x74\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x8E\x2A\x2A\x2A\x2A\x8B\x96\x2A\x2A\x2A\x2A\x8B\x86\x2A\x2A\x2A\x2A\x89\x2A\x2A\x2A\x8B\x8E\x2A\x2A\x2A\x2A\xC1\x2A\x2A\xF6\x2A\x2A\x89\x2A\x2A\x2A\x89\x2A\x2A\x2A\x74\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x96\x2A\x2A\x2A\x2A\x8B\x86\x2A\x2A\x2A\x2A\x8B\x8E\x2A\x2A\x2A\x2A\x6A\x2A\x89\x2A\x2A\x2A\x68\x2A\x2A\x2A\x2A\x8D\x2A\x2A\x2A\x89\x2A\x2A\x2A\x52\x8D\x2A\x2A\x2A\x50\x89\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x8E\x2A\x2A\x2A\x2A\x8B\x2A\x8D"
						/* ? ? ? ? ? ? 8B 86 ? ? ? ? C1 ? ? A8 ? 57 74 ? E8 ? ? ? ? 8B 8E ? ? ? ? 8B 96 ? ? ? ? 8B 86 ? ? ? ? 89 ? ? ? 8B 8E ? ? ? ? C1 ? ? F6 ? ? 89 ? ? ? 89 ? ? ? 74 ? 8B ? E8 ? ? ? ? 8B 96 ? ? ? ? 8B 86 ? ? ? ? 8B 8E ? ? ? ? 6A ? 89 ? ? ? 68 ? ? ? ? 8D ? ? ? 89 ? ? ? 52 8D ? ? ? 50 89 ? ? ? E8 ? ? ? ? 8B 8E ? ? ? ? 8B ? 8D */
			}

			/**
			 * CFirstAidKit::FinishHealing()
			 *
			 * How to find on Windows:
			 * 1. Search for the "HealedByFriend" string.
			 * 2. The string can only be found in this function.
			 **/
			"CFirstAidKit::FinishHealing"
			{
				"library"	"server"
				"linux"		"@_ZN12CFirstAidKit13FinishHealingEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x55\x89\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x0F"
						/* ? ? ? ? ? ? 55 89 ? ? ? E8 ? ? ? ? 8B ? 85 ? 0F */
			}

			/**
			 * CFirstAidKit::StartHealing(CFirstAidKit::HealTargetType)
			 *
			 * How to find on Windows:
			 * 1. Search for the "PlayerHealing" or "PlayerHealingOther" string.
			 * 2. The string can only be found in this function.
			 **/
			"CFirstAidKit::StartHealing"
			{
				"library"	"server"
				"linux"		"@_ZN12CFirstAidKit12StartHealingENS_14HealTargetTypeE.part.43"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x53\x55\x56\x8D\xB1\x2A\x2A\x2A\x2A\x57\x89"
						/* ? ? ? ? ? ? ? ? 53 55 56 8D B1 ? ? ? ? 57 89 */
			}

			/**
			 * CSmokeCloudSystem::FireGameEvent(IGameEvent *)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CSmokeCloudSystem" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CSmokeCloudSystem::FireGameEvent"
			{
				"library"	"server"
				"linux"		"@_ZN17CSmokeCloudSystem13FireGameEventEP10IGameEvent" // change 57 to C3
				"windows"	"\x83\x2A\x2A\x56\x8B\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x57\x8B\x2A\x8B\x2A\xFF\x2A\x3D\x2A\x2A\x2A\x2A\x74\x2A\x68\x2A\x2A\x2A\x2A\x50\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x85\x2A\x0F\x85\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x6A\x2A\x68\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x50\xE8\x2A\x2A\x2A\x2A\x8B"
						/* 83 ? ? 56 8B ? ? ? 8B ? 8B ? ? 57 8B ? 8B ? FF ? 3D ? ? ? ? 74 ? 68 ? ? ? ? 50 E8 ? ? ? ? 83 ? ? 85 ? 0F 85 ? ? ? ? 8B ? 8B ? ? 6A ? 68 ? ? ? ? 8B ? FF ? 50 E8 ? ? ? ? 8B */ // change 83 ?? ?? to C2 04 00
			}

			/**
			 * CTankClaw::DoSwing()
			 *
			 * How to find on Windows:
			 * 1a. Search for the "rhand" string.
			 * 2a. The string can only be found in this function.
			 * 1b. Search for the "ValveBiped.Bip01_R_Hand" string.
			 * 2b. One of the functions that references that string should be this function.
			 **/
			"CTankClaw::DoSwing"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankClaw7DoSwingEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x74\x2A\x8D\x2A\x2A\x2A\x50\x8D\x2A\x2A\x2A\x51\x68"
						/* ? ? ? ? ? ? ? E8 ? ? ? ? 8B ? 85 ? 74 ? 8D ? ? ? 50 8D ? ? ? 51 68 */
			}

			/**
			 * CTankClaw::GroundPound()
			 *
			 * How to find on Windows:
			 * 1. Locate the "CTankClaw::SweepFist" function.
			 * 2. Click on the second to last function call to go to "CTerrorWeapon::MarkAsHit".
			 * 3. This function calls "CTerrorWeapon::MarkAsHit" twice.
			 * 4. To pinpoint the right function, look for the one that sets multiple variables to "0".
			 **/
			"CTankClaw::GroundPound"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankClaw11GroundPoundEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x81\xEC\x2A\x2A\x2A\x2A\x53\x56\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x85"
						/* ? ? ? ? ? ? 81 EC ? ? ? ? 53 56 57 8B ? E8 ? ? ? ? 8B ? 85 */
			}

			/**
			 * CTankClaw::OnPlayerHit(CTerrorPlayer*, bool)
			 *
			 * How to find on Windows:
			 * 1a. Search for the "PlayerGroundPoundedByTank" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTankClaw" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTankClaw::OnPlayerHit"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankClaw11OnPlayerHitEP13CTerrorPlayerb"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x55\x56\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\xB4"
						/* ? ? ? ? ? ? 53 55 56 57 8B ? E8 ? ? ? ? 8B B4 */
			}

			/**
			 * CTankClaw::SweepFist(Vector const&, Vector const&)
			 *
			 * How to find on Windows:
			 * 1. Locate the "CTankClaw::DoSwing" function.
			 * 2. The last function call should be this function.
			 **/
			"CTankClaw::SweepFist"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankClaw9SweepFistERK6VectorS2_.constprop.248"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x55\x56\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x0D"
						/* ? ? ? ? ? ? 55 56 8B ? E8 ? ? ? ? 8B ? 85 ? 0F 84 ? ? ? ? 8B 0D */
			}

			/**
			 * CTankRock::Detonate()
			 *
			 * How to find on Windows:
			 * 1a. Search for the "tank_rock_throw_impact_stump" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTankRock" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTankRock::Detonate"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankRock8DetonateEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x80\xBE\x2A\x2A\x2A\x2A\x2A\x57\x0F\x84\x2A\x2A\x2A\x2A\xD9"
						/* ? ? ? ? ? ? 8B ? 80 BE ? ? ? ? ? 57 0F 84 ? ? ? ? D9 */
			}

			/**
			 * CTankRock::OnRelease(Vector const&,QAngle const&,Vector const&,Vector const&)
			 *
			 * How to find on Windows:
			 * 1. Search for the "HulkZombie.Throw.FlyLoop" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTankRock::OnRelease"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankRock9OnReleaseERK6VectorRK6QAngleS2_S2_.constprop.121"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xC7\x86\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x57"
						/* ? ? ? ? ? ? ? ? ? ? ? C7 86 ? ? ? ? ? ? ? ? E8 ? ? ? ? 8B ? ? ? 57 */
			}

			/**
			 * CTerrorGameMovement::DoJump(Vector*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "player_jump" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorGameMovement::DoJump"
			{
				"library"	"server"
				"linux"		"@_ZN19CTerrorGameMovement6DoJumpEP6Vector"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x57\x6A\x2A\xFF\x2A\x8B\x8E\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x6A\x2A\x6A"
						/* ? ? ? ? ? ? 8B ? 8B 90 ? ? ? ? 57 6A ? FF ? 8B 8E ? ? ? ? 8B ? 8B 90 ? ? ? ? 6A ? 6A */
			}

			/**
			 * CTerrorGameMovement::DoJump(Vector*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "57.0" value in the "CTerrorGameMovement::DoJump" function.
			 * 2. Go to the instruction for that line in the code.
			 * 3. Double-click the offset that represents that value to get the address.
			 **/
			"CTerrorGameMovement::DoJump::Value"
			{
				"library"	"server"
				"linux"		"\x00\x00\x64\x42\x00\x00\xC8\x44"
				"windows"	"\x00\x00\x00\x00\x00\x80\x4C\x40"
			}

			/**
			 * CTerrorGameRules::GetMissionFirstMap(KeyValues**)
			 *
			 * How to find on Windows:
			 * 1. Search for the "Game/chapter" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorGameRules::GetMissionFirstMap"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules18GetMissionFirstMapEPP9KeyValues"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x85\x2A\x74\x2A\xC7\x07\x2A\x2A\x2A\x2A\x8B\x0D\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\xFF\x2A\x8B\x2A\x8B\x2A\x8B\x2A\x2A\x6A\x2A\xFF\x2A\x8B\x2A\x85\x2A\x75\x2A\x5F\x5E\xC3\x8B\x0D\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x57\x56\xFF\x2A\x6A\x2A\x68\x2A\x2A\x2A\x2A\x8B\x2A\x8B"
						/* ? ? ? ? ? ? 85 ? 74 ? C7 07 ? ? ? ? 8B 0D ? ? ? ? 8B ? 8B ? ? FF ? 8B ? 8B ? 8B ? ? 6A ? FF ? 8B ? 85 ? 75 ? 5F 5E C3 8B 0D ? ? ? ? 8B ? 8B ? ? 57 56 FF ? 6A ? 68 ? ? ? ? 8B ? 8B */
			}

			/**
			 * CTerrorGameRules::GetMissionInfo()
			 *
			 * How to find on Windows:
			 * 1. Search for the "%3.2f: Director: Finale state = FINALE_HORDE_ATTACK_1\n" string.
			 * 2. Both functions that reference the string call this function.
			 * 3. The first function call below the string should be this function.
			 **/
			"CTerrorGameRules::GetMissionInfo"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules14GetMissionInfoEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x56\xFF\x2A\x8B\x2A\x8B\x2A\x8B\x2A\x2A\x6A\x2A\xFF\x2A\x8B\x2A\x85\x2A\x75\x2A\x5E"
						/* ? ? ? ? ? ? ? 8B ? 8B ? ? 56 FF ? 8B ? 8B ? 8B ? ? 6A ? FF ? 8B ? 85 ? 75 ? 5E */
			}

			/**
			 * CTerrorGameRules::IsCoopMode()
			 *
			 * How to find on Windows:
			 * 1. Search for the "Director::StartScenarioExit\n" string.
			 * 2. One of the functions that references that string should be "outtro_stats_done".
			 * 3. The second function call in "outtro_stats_done" should be this function.
			 **/
			"CTerrorGameRules::IsCoopMode"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules10IsCoopModeEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x74\x2A\xB8\xA0\x2A\x2A\x2A\xEB\x2A\xA1\x54\x2A\x2A\x2A\x8B\x2A\x2A\x85\x2A\x75\x2A\xB8\x7C\x2A\x2A\x2A\x68\x50\x2A\x2A\x2A\x50\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\xF7"
						/* ? ? ? ? ? ? ? ? ? ? 74 ? B8 A0 ? ? ? EB ? A1 54 ? ? ? 8B ? ? 85 ? 75 ? B8 7C ? ? ? 68 50 ? ? ? 50 E8 ? ? ? ? 83 ? ? F7 */
			}

			/**
			 * CTerrorGameRules::IsHoldoutMode()
			 *
			 * How to find on Windows:
			 * 1. Search for the "survival" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorGameRules::IsHoldoutMode"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules13IsHoldoutModeEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x74\x2A\xB8\xA0\x2A\x2A\x2A\xEB\x2A\xA1\x54\x2A\x2A\x2A\x8B\x2A\x2A\x85\x2A\x75\x2A\xB8\x7C\x2A\x2A\x2A\x68\xF4\x2A\x2A\x2A\x50\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\xF7"
						/* ? ? ? ? ? ? ? ? ? ? 74 ? B8 A0 ? ? ? EB ? A1 54 ? ? ? 8B ? ? 85 ? 75 ? B8 7C ? ? ? 68 F4 ? ? ? 50 E8 ? ? ? ? 83 ? ? F7 */
			}

			/**
			 * CTerrorGameRules::IsMissionFinalMap()
			 *
			 * How to find on Windows:
			 * 1. Search for the "Game/chapter" string.
			 * 2. One of the functions that references that string should be this function.
			 * 3. This function references the string twice.
			 **/
			"CTerrorGameRules::IsMissionFinalMap"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules17IsMissionFinalMapEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x56\xFF\x2A\x8B\x2A\x8B\x2A\x8B\x2A\x2A\x6A\x2A\xFF\x2A\x8B\x2A\x85\x2A\x75\x2A\xB0"
						/* ? ? ? ? ? ? 8B ? 8B ? ? 56 FF ? 8B ? 8B ? 8B ? ? 6A ? FF ? 8B ? 85 ? 75 ? B0 */
			}

			/**
			 * CTerrorGameRules::IsVersusMode()
			 *
			 * Note: (Windows) This function is in-lined with the "CTerrorGameRules::HasPlayerControlledZombies" function.
			 *
			 * How to find on Windows:
			 * 1. Search for the "teamversus" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorGameRules::IsVersusMode"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules12IsVersusModeEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x74\x2A\xB8\xA0\x2A\x2A\x2A\xEB\x2A\xA1\x54\x2A\x2A\x2A\x8B\x2A\x2A\x85\x2A\x75\x2A\xB8\x7C\x2A\x2A\x2A\x68\x04"
						/* ? ? ? ? ? ? ? ? ? ? 74 ? B8 A0 ? ? ? EB ? A1 54 ? ? ? 8B ? ? 85 ? 75 ? B8 7C ? ? ? 68 04 */
			}

			/**
			 * CTerrorGun::EquipSecondWeapon()
			 *
			 * How to find on Windows:
			 * 1a. Search for the "Player.PickupWeapon" string.
			 * 2a. One of the functions that references that string should be this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTerrorGun" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTerrorGun::EquipSecondWeapon"
			{
				"library"	"server"
				"linux"		"@_ZN10CTerrorGun17EquipSecondWeaponEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x80\xBE\x2A\x2A\x2A\x2A\x2A\x8D\x9E\x2A\x2A\x2A\x2A\x74\x2A\x5E"
						/* ? ? ? ? ? ? ? 80 BE ? ? ? ? ? 8D 9E ? ? ? ? 74 ? 5E */
			}

			/**
			 * CTerrorGun::Use(CBaseEntity *, CBaseEntity *, USE_TYPE, float)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorGun" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CTerrorGun::Use"
			{
				"library"	"server"
				"linux"		"@_ZN10CTerrorGun3UseEP11CBaseEntityS1_8USE_TYPEf"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x85\x2A\x8B\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x8B"
						/* ? ? ? ? ? ? ? ? ? 85 ? 8B ? 0F 84 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 84 ? 0F 84 ? ? ? ? 8B ? 8B */
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * How to find on Windows:
			 * 1a. Search for any of the following strings (they can each only be found in this function):
			 * - "blood_bleedout"
			 * - "SubjectIsA:%s,Distance:%f"
			 * - "KilledZombie"
			 * - "DeadCharacter:"
			 * - ",SubjectTeam:Survivor"
			 * - "SurvivorDied"
			 * - "infected_explosive_barrel_kill"
			 * - "boomer_exploded"
			 * - "splashedbile"
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::Event_Killed"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer12Event_KilledERK15CTakeDamageInfo"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x55\x56\x8B\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x57\xFF\x2A\x88"
						/* ? ? ? ? ? ? 53 55 56 8B ? 8B ? 8B 90 ? ? ? ? 57 FF ? 88 */
			}

			/**
			 * CTerrorPlayer::GoAwayFromKeyboard()
			 *
			 * How to find on Windows:
			 * 1. Search for the "player_afk" string.
			 * 2. The string can only be found in this function.
			 **/
			"CTerrorPlayer::GoAwayFromKeyboard"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer18GoAwayFromKeyboardEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x9E"
						/* ? ? ? ? ? ? 8B ? 8B ? 8B 90 ? ? ? ? 8B 9E */
			}

			/**
			 * CTerrorPlayer::MaterializeFromGhost()
			 *
			 * How to find on Windows:
			 * 1. Search for the "%s materialized from spawn mode as a %s\n" string.
			 * 2. The string can only be found in this function.
			 **/
			"CTerrorPlayer::MaterializeFromGhost"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer20MaterializeFromGhostEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xFF\x2A\x50\xE8\x2A\x2A\x2A\x2A\x50\x8D\x86"
						/* ? ? ? ? ? ? ? ? ? ? ? FF ? 50 E8 ? ? ? ? 50 8D 86 */
			}

			/**
			 * CTerrorPlayer::OnBeginChangeLevel(char const*, KeyValues *)
			 *
			 * How to find on Windows:
			 * 1a. Search for the "Saving %s for transition at %f %f %f\n" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::OnBeginChangeLevel"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer18OnBeginChangeLevelEPKcP9KeyValues"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x56\x8B\x2A\x74\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x0F"
						/* ? ? ? ? ? ? ? ? 56 8B ? 74 ? E8 ? ? ? ? 84 ? 0F */
			}

			/**
			 * CTerrorPlayer::OnEnterGhostState()
			 *
			 * How to find on Windows:
			 * 1a. Search for the "spawnmode_bar" string.
			 * 2a. One of the functions that references that string should be this function.
			 * 3a. This function should also contain "data" and "zombieClass" strings.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::OnEnterGhostState"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer17OnEnterGhostStateEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x8D\x8E\x2A\x2A\x2A\x2A\x57\xFF\x2A\x8B"
						/* ? ? ? ? ? ? ? ? ? ? 8B ? ? 8D 8E ? ? ? ? 57 FF ? 8B */
			}

			/**
			 * CTerrorPlayer::OnFalling()
			 *
			 * How to find on Windows:
			 * 1. Search for the "PlayerZombie.Fall" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorPlayer::OnFalling"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer9OnFallingEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x0F\x85\x2A\x2A\x2A\x2A\x8D"
						/* ? ? ? ? ? ? 57 8B ? E8 ? ? ? ? 83 ? ? 0F 85 ? ? ? ? 8D */
			}

			/**
			 * CTerrorPlayer::OnIncapacitatedAsTank(CTakeDamageInfo const&)
			 *
			 * How to find on Windows:
			 * 1. Search for the "deathEvent" or "HulkZombie.Die" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorPlayer::OnIncapacitatedAsTank"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer21OnIncapacitatedAsTankERK15CTakeDamageInfo"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x50\xE8\x2A\x2A\x2A\x2A\x84\x2A\x74\x2A\x81"
						/* ? ? ? ? ? ? ? ? ? ? 50 E8 ? ? ? ? 84 ? 74 ? 81 */
			}

			/**
			 * CTerrorPlayer::OnITExpired()
			 *
			 * How to find on Windows:
			 * 1. Search for the "PlayerVomitExpired" string.
			 * 2. The string can only be found in this function.
			 **/
			"CTerrorPlayer::OnITExpired"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer11OnITExpiredEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x57\x8B\x2A\xD8\x9F\x2A\x2A\x2A\x2A\x8D\xB7\x2A\x2A\x2A\x2A\xDF\x2A\xF6\x2A\x2A\x7B\x2A\x8B\x2A\x2A\x8B\x2A\x8D\x2A\x2A\x56\xFF\x2A\xD9\x05\x2A\x2A\x2A\x2A\xD9\x2A\x8B\x2A\x6A"
						/* ? ? ? ? ? ? 56 57 8B ? D8 9F ? ? ? ? 8D B7 ? ? ? ? DF ? F6 ? ? 7B ? 8B ? ? 8B ? 8D ? ? 56 FF ? D9 05 ? ? ? ? D9 ? 8B ? 6A */
			}

			/**
			 * CTerrorPlayer::OnLadderDismount()
			 *
			 * How to find on Windows:
			 * 1. Search for the "CTerrorPlayer::PlayerRunCommand" string.
			 * 2. The string can only be found in "CTerrorPlayer::PlayerRunCommand".
			 * 3. The last function call in "CTerrorPlayer::PlayerRunCommand" should be this function.
			 **/
			"CTerrorPlayer::OnLadderDismount"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer16OnLadderDismountEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x75\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x85\x2A\x74\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x8B\x82\x2A\x2A\x2A\x2A\xFF"
						/* ? ? ? ? ? ? ? ? 83 ? ? 75 ? 8B ? E8 ? ? ? ? 85 ? 74 ? 8B ? E8 ? ? ? ? 8B ? 8B ? 8B 82 ? ? ? ? FF */
			}

			/**
			 * CTerrorPlayer::OnLadderMount()
			 *
			 * How to find on Windows:
			 * 1. Search for the "Player.Fall" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorPlayer::OnLadderMount"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer13OnLadderMountEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x6A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x83"
						/* ? ? ? ? ? ? 8B ? E8 ? ? ? ? 8B ? E8 ? ? ? ? 6A ? 8B ? E8 ? ? ? ? 8B ? E8 ? ? ? ? 83 */
			}

			/**
			 * CTerrorPlayer::OnRevived()
			 *
			 * How to find on Windows:
			 * 1a. Search for the "ReviveType" or "RevivedByFriend" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::OnRevived"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer9OnRevivedEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x57\x8B\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\xFF\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\xE8"
						/* ? ? ? ? ? ? 57 8B ? 8B ? 8B 90 ? ? ? ? FF ? 84 ? 0F 84 ? ? ? ? 8B ? E8 */
			}

			/**
			 * CTerrorPlayer::OnShovedByPounceLanding(CTerrorPlayer*, bool)
			 *
			 * How to find on Windows:
			 * 1. Search for the "Tongue letting go on getting bashed." string.
			 * 2. The string can only be found in "CTerrorPlayer::OnStunned".
			 * 3. One of the functions that calls "CTerrorPlayer::OnStunned" should be this function.
			 **/
			"CTerrorPlayer::OnShovedByPounceLanding"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer23OnShovedByPounceLandingEPS_b"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x0F\x85\x2A\x2A\x2A\x2A\x57\x8B\x2A\x2A\x2A\x85"
						/* ? ? ? ? ? ? E8 ? ? ? ? 84 ? 0F 85 ? ? ? ? 57 8B ? ? ? 85 */
			}

			/**
			 * CTerrorPlayer::OnShovedBySurvivor(CTerrorPlayer*, Vector const&)
			 *
			 * How to find on Windows:
			 * 1. Search for the "Survivor was lunged while %sfacing the hunter and %sbashing\n" string.
			 * 2. The string can only be found in one function.
			 * 3. The very last function call in the code block that comes after the line where that string is referenced should be this function.
			 **/
			"CTerrorPlayer::OnShovedBySurvivor"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer18OnShovedBySurvivorEPS_RK6Vector"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x0F\x85\x2A\x2A\x2A\x2A\x8B\x8C"
						/* ? ? ? ? ? ? 56 8B ? E8 ? ? ? ? 84 ? 0F 85 ? ? ? ? 8B 8C */
			}

			/**
			 * CTerrorPlayer::OnStaggered(CBaseEntity*, Vector const*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "Player.Shoved" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorPlayer::OnStaggered"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer11OnStaggeredEP11CBaseEntityPK6Vector"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x0F\x85\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F\x85\x2A\x2A\x2A\x2A\x53\x55"
						/* ? ? ? ? ? ? E8 ? ? ? ? 84 ? 0F 85 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 84 ? 0F 85 ? ? ? ? 53 55 */
			}

			/**
			 * CTerrorPlayer::OnTakeDamage_Alive(CTakeDamageInfo const&)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::OnTakeDamage_Alive"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer18OnTakeDamage_AliveERK15CTakeDamageInfo"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x83\x2A\x2A\x8B\x2A\x0F\x84"
						/* ? ? ? ? ? ? ? ? ? 8B ? ? 83 ? ? 8B ? 0F 84 */
			}

			/**
			 * CTerrorPlayer::OnVomitedUpon(CTerrorPlayer*, bool, bool)
			 *
			 * How to find on Windows:
			 * 1. Search for any of the following strings (they can each only be found in this function):
			 * - "#L4D_NOTIFY_VOMIT_ON"
			 * - "PlayerNeutralizedVomit"
			 * - "PlayerVomitInFace"
			 **/
			"CTerrorPlayer::OnVomitedUpon"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer13OnVomitedUponEPS_bb"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x74\x2A\xA1\x2A\x2A\x2A\x2A\x80"
						/* ? ? ? ? ? ? 57 8B ? E8 ? ? ? ? 84 ? 74 ? A1 ? ? ? ? 80 */
			}

			/**
			 * CTerrorPlayer::PreThink()
			 *
			 * How to find on Windows:
			 * 1a. Search for the "#L4D_idle_spectator" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::PreThink"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer8PreThinkEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x85"
						/* ? ? ? ? ? ? ? E8 ? ? ? ? 8B ? E8 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 85 */
			}

			/**
			 * CTerrorPlayer::RoundRespawn()
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::RoundRespawn"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer12RoundRespawnEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x75\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\xC6"
						/* ? ? ? ? ? ? ? ? E8 ? ? ? ? 84 ? 75 ? 8B ? E8 ? ? ? ? C6 */
			}

			/**
			 * CTerrorPlayer::SetMainActivity(Activity, bool)
			 *
			 * How to find on Windows:
			 * 1. Search for the "%f: %s plays %s\n" string.
			 * 2. The string can only be found in this function.
			 **/
			"CTerrorPlayer::SetMainActivity"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer15SetMainActivityE8Activityb"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x3D\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x8B\x2A\x8B\x2A\x89\x2A\x2A\x2A\xFF\x2A\x8B"
						/* ? ? ? ? ? ? 8B 3D ? ? ? ? 8B ? 8B ? ? 8B ? 8B ? 89 ? ? ? FF ? 8B */
			}

			/**
			 * CTerrorPlayer::StartReviving(CTerrorPlayer*)
			 *
			 * How to find on Windows:
			 * 1. Search for any of the following strings (they can each only be found in this function):
			 * - "Tongue letting because victim is being revived"
			 * - "%s starts reviving %s"
			 * - "revive_begin"
			 * - "Reviving Friend..."
			 * - "Getting Revived..."
			 * - "PlayerHeal"
			 * - "PlayerLedgeSaveCritical"
			 * - "PlayerReviveFriendCritical"
			 * - "PlayerLedgeSave"
			 * - "PlayerReviveFriend"
			 **/
			"CTerrorPlayer::StartReviving"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer13StartRevivingEPS_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x8B\x9C\x2A\x2A\x2A\x2A\x2A\x8B\x83\x2A\x2A\x2A\x2A\x83"
						/* ? ? ? ? ? ? 53 8B 9C ? ? ? ? ? 8B 83 ? ? ? ? 83 */
			}

			/**
			 * CTerrorWeapon::CanDeploy()
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorWeapon" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CTerrorWeapon::CanDeployFor"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorWeapon9CanDeployEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\xE8"
						/* ? ? ? ? ? ? ? ? ? 8B ? 85 ? 0F 84 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 84 ? 0F 84 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 8B ? E8 */
			}

			/**
			 * CTerrorWeapon::SecondaryAttack()
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorWeapon" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CTerrorWeapon::SecondaryAttack"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorWeapon15SecondaryAttackEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F\x85\x2A\x2A\x2A\x2A\x8B\x2A\x8B"
						/* ? ? ? ? ? ? ? ? ? 8B ? 85 ? 0F 84 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 84 ? 0F 84 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 84 ? 0F 85 ? ? ? ? 8B ? 8B */
			}

			/**
			 * CWeaponSpawn::Use(CBaseEntity *, CBaseEntity *, USE_TYPE, float)
			 *
			 * How to find on Windows:
			 * 1a. Search for the "spawner_give_item" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. In IDA Pro, go to the ".rdata" section of the Windows binary.
			 * 3b. Search for "CWeaponSpawn::`vftable'" to jump to the "CWeaponSpawn" vtable.
			 * 4b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 5b. Look for the target function in the Windows binary.
			 **/
			"CWeaponSpawn::Use"
			{
				"library"	"server"
				"linux"		"@_ZN12CWeaponSpawn3UseEP11CBaseEntityS1_8USE_TYPEf"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x85\x2A\x8B\x2A\x89\x2A\x2A\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B"
						/* ? ? ? ? ? ? ? ? ? 85 ? 8B ? 89 ? ? ? 0F 84 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 84 ? 0F 84 ? ? ? ? 8B */
			}

			/**
			 * InfectedExecAction::OnInjured(Infected *, CTakeDamageInfo const&)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "InfectedExecAction" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"InfectedExecAction::OnInjured"
			{
				"library"	"server"
				"linux"		"@_ZN18InfectedExecAction9OnInjuredEP8InfectedRK15CTakeDamageInfo"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x56\x57\x8B\x2A\x2A\x2A\x32\x2A\xF7"
						/* ? ? ? ? ? ? ? ? ? 56 57 8B ? ? ? 32 ? F7 */
			}

			/**
			 * KeyValues::GetString(char const*, char const*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "%3.2f: Director: Finale state = FINALE_HORDE_ATTACK_1\n" string.
			 * 2. Both functions that reference the string call this function.
			 * 3. The second function call below the string should be this function.
			 **/
			"KeyValues::GetString"
			{
				"library"	"server"
				"linux"		"@_ZN9KeyValues9GetStringEPKcS1_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x8B\x9C\x2A\x2A\x2A\x2A\x2A\x56\x57\x6A\x2A\x53\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x0F\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x0F"
						/* ? ? ? ? ? ? 53 8B 9C ? ? ? ? ? 56 57 6A ? 53 8B ? E8 ? ? ? ? 8B ? 85 ? 0F 84 ? ? ? ? 0F ? ? ? 83 ? ? 83 ? ? 0F */
			}

			/**
			 * PassServerEntityFilter(IHandleEntity const*, IHandleEntity const*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "RagdollImpact" string.
			 * 2. One of the functions that references that string should be "CBaseEntity::FireBullets".
			 * 3. Click on the first function call below the string to go to "Pickup_ForcePlayerToDropThisObject".
			 * 4. Check the references for "Pickup_ForcePlayerToDropThisObject".
			 * 5. One of the functions that calls "Pickup_ForcePlayerToDropThisObject" should be "CTraceFilterMelee::ShouldHitEntity".
			 * 6. The second function call in "CTraceFilterMelee::ShouldHitEntity" should be this function.
			 **/
			"PassServerEntityFilter"
			{
				"library"	"server"
				"linux"		"@_Z22PassServerEntityFilterPK13IHandleEntityS1_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x75\x2A\xB0\x2A\x5F\xC3\x56"
						/* ? ? ? ? ? ? ? 75 ? B0 ? 5F C3 56 */
			}

			/**
			 * PlayerLocomotion::GetMaxJumpHeight()
			 *
			 * Note: This is only used for the default jump height (57.0) address on Linux.
			 **/
			"PlayerLocomotion::GetMaxJumpHeight"
			{
				"library"	"server"
				"linux"		"@_ZNK16PlayerLocomotion16GetMaxJumpHeightEv"
			}

			/**
			 * SurvivorLegsMeetRescueVehicleArrival::Update(SurvivorBot*, float)
			 *
			 * Note: This is only used for the "CDirector" address on Windows.
			 *
			 * How to find:
			 * 1a. Search for the "The rescue vehicle is here!!!" or "%3.2f: %s ERROR: No RESCUE_VEHICLE area!\n" string.
			 * 2a. One of the functions that references that string should be this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "SurvivorLegsMeetRescueVehicleArrival" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"SurvivorLegsMeetRescueVehicleArrival::Update"
			{
				"library"	"server"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x0D\x2A\x2A\x2A\x2A\x33\x2A\x38"
						/* ? ? ? ? ? ? ? 8B 0D ? ? ? ? 33 ? 38 */
			}

			/**
			 * Tank::EnterStasis()
			 *
			 * How to find on Windows:
			 * 1. Search for any of the following strings (they can each only be found in one function):
			 * - "Tank offer: Starting the lottery\n"
			 * - "Tank offer: Going to the only PZ\n"
			 * - "Tank offer: making a bot, and giving him to nobody\n"
			 * 2. This function should be referenced by a function that is two function calls above the "Tank offer: Starting the lottery\n" string.
			 * 3. This function should be the last function call in that function.
			 **/
			"Tank::EnterStasis"
			{
				"library"	"server"
				"linux"		"@_ZN4Tank11EnterStasisEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x0F\x85\x2A\x2A\x2A\x2A\x83\x2A\x2A\x2A\x0F\x84\x2A\x2A\x2A\x2A\x0F"
						/* ? ? ? ? ? ? ? ? ? ? 0F 85 ? ? ? ? 83 ? ? ? 0F 84 ? ? ? ? 0F */
			}

			/**
			 * Tank::LeaveStasis()
			 *
			 * How to find on Windows:
			 * 1. Search for the "Tank committing suicide\n" string.
			 * 2. This function is called above the string.
			 **/
			"Tank::LeaveStasis"
			{
				"library"	"server"
				"linux"		"@_ZN4Tank11LeaveStasisEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x0F\x84\x2A\x2A\x2A\x2A\x83\x2A\x2A\x2A\x74\x2A\x0F"
						/* ? ? ? ? ? ? ? ? ? ? 0F 84 ? ? ? ? 83 ? ? ? 74 ? 0F */
			}

			/**
			 * ZombieManager::ReplaceTank(CTerrorPlayer*, CTerrorPlayer*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "TANK OFFER: Looking for players\n" string.
			 * 2. The last function call in that function should be this function.
			 **/
			"ZombieManager::ReplaceTank"
			{
				"library"	"server"
				"linux"		"@_ZN13ZombieManager11ReplaceTankEP13CTerrorPlayerS1_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\x57\x8B\x2A\xFF\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x0F\x85\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x83"
						/* ? ? ? ? ? ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? 57 8B ? FF ? 84 ? 0F 84 ? ? ? ? 8B ? E8 ? ? ? ? 83 ? ? 0F 85 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 83 */
			}

			/**
			 * ZombieManager::SpawnTank(Vector const&, QAngle const&)
			 *
			 * How to find on Windows:
			 * 1. Search for the "Failed to find a tank spawn position in area %d\n" string.
			 * 2. The second function call in that function should be this function.
			 **/
			"ZombieManager::SpawnTank"
			{
				"library"	"server"
				"linux"		"@_ZN13ZombieManager9SpawnTankERK6VectorRK6QAngle"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x83\x2A\x2A\x85\x2A\x75\x2A\x5E\xC2\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x6A\x2A\x6A\x2A\x6A\x2A\x8B\x2A\xFF\x2A\x6A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x50\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x2A\x51\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x89\x35\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x8B\x2A\xFF\x2A\x6A\x2A\x6A\x2A\xB9\x2A\x2A\x2A\x2A\xC7\x05\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x0D"
						/* ? ? ? ? ? ? E8 ? ? ? ? 8B ? 83 ? ? 85 ? 75 ? 5E C2 ? ? 8B ? 8B 90 ? ? ? ? 6A ? 6A ? 6A ? 8B ? FF ? 6A ? 8B ? E8 ? ? ? ? 8B ? ? ? 50 8B ? E8 ? ? ? ? 8B ? ? ? 51 8B ? E8 ? ? ? ? 89 35 ? ? ? ? 8B ? 8B ? ? 8B ? FF ? 6A ? 6A ? B9 ? ? ? ? C7 05 ? ? ? ? ? ? ? ? E8 ? ? ? ? 8B 0D */
			}
		}
	}

	"left4dead2"
	{
		"Functions"
		{
			/**
			 * CBaseBackpackItem::StartAction(CBaseBackpackItem::BackpackItemActionType, CBaseBackpackItem::BackpackItemActionTrigger)
			 *
			 * Note: Detouring as a pre-hook for changing the following per player before starting any actions:
			 * - "first_aid_kit_use_duration"
			 * - "ammo_pack_use_duration"
			 * - "cola_bottles_use_duration"
			 * - "defibrillator_use_duration"
			 * - "gas_can_use_duration"
			 * - "upgrade_pack_use_duration"
			 * Note: Detouring as a post-hook for changing the above back to default values after starting any actions.
			 **/
			"MTDetour_CBaseBackpackItem::StartAction"
			{
				"signature"	"CBaseBackpackItem::StartAction"
				"callconv"	"thiscall"
				"return"	"int"
				"this"		"entity"
				"arguments"
				{
					"actionType"
					{
						"type"		"int"
					}
					"actionTrigger"
					{
						"type"		"int"
					}
				}
			}

			/**
			 * CFirstAidKit::OnActionComplete(CTerrorPlayer*, CBaseEntity*)
			 *
			 * Note: Detouring as a pre-hook for changing "first_aid_heal_percent" per player before healing finishes.
			 * Note: Detouring as a post-hook for changing "first_aid_heal_percent" back to default value after healing finishes.
			 **/
			"MTDetour_CFirstAidKit::OnActionComplete"
			{
				"signature"	"CFirstAidKit::OnActionComplete"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"healer"
					{
						"type"		"cbaseentity"
					}
					"subject"
					{
						"type"		"cbaseentity"
					}
				}
			}

			/**
			 * CTankRock::Create(Vector const&, QAngle const&, Vector const&, CBaseCombatCharacter*)
			 *
			 * Note: Detouring as a post-hook for setting Tank rock colors after they are spawned by "env_rock_launcher" entity.
			 **/
			"MTDetour_CTankRock::Create"
			{
				"signature"	"CTankRock::Create"
				"callconv"	"cdecl"
				"return"	"cbaseentity"
				"arguments"
				{
					"origin"
					{
						"type"		"vectorptr"
					}
					"angles"
					{
						"type"		"vectorptr"
					}
					"velocity"
					{
						"type"		"vectorptr"
					}
					"owner"
					{
						"type"		"cbaseentity"
					}
				}
			}

			/**
			 * CTerrorGun::FireBullet()
			 *
			 * Note: Detouring as a pre-hook for changing "phys_pushscale" per player before firing a bullet.
			 * Note: Detouring as a post-hook for changing "phys_pushscale" back to default value after firing a bullet.
			 **/
			"MTDetour_CTerrorGun::FireBullet"
			{
				"signature"	"CTerrorGun::FireBullet"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * CTerrorMeleeWeapon::SecondaryAttack()
			 * Note: Detouring as a pre-hook for changing "z_gun_swing_interval" per player before shoving with a melee weapon.
			 * Note: Detouring as a post-hook for changing "z_gun_swing_interval" back to default value after shoving with a melee weapon.
			 **/
			"MTDetour_CTerrorMeleeWeapon::SecondaryAttack"
			{
				"signature"	"CTerrorMeleeWeapon::SecondaryAttack"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
			}

			/**
			 * CTerrorMeleeWeapon::TestMeleeSwingCollision(Vector const&)
			 *
			 * Note: Detouring as a pre-hook for changing "melee_range" per player before swinging melee weapon.
			 * Note: Detouring as a post-hook for changing "melee_range" back to default value after swinging melee weapon.
			 **/
			"MTDetour_CTerrorMeleeWeapon::TestMeleeSwingCollision"
			{
				"signature"	"CTerrorMeleeWeapon::TestMeleeSwingCollision"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"swingAngle"
					{
						"type"		"vectorptr"
					}
				}
			}

			/**
			 * CTerrorPlayer::DoAnimationEvent(PlayerAnimEvent_t, int)
			 *
			 * Note: Detouring as a pre-hook for skipping animations after Tank hits per player for faster recovery.
			 **/
			"MTDetour_CTerrorPlayer::DoAnimationEvent"
			{
				"signature"	"CTerrorPlayer::DoAnimationEvent"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"animation"
					{
						"type"		"int"
					}
					"a2"
					{
						"type"		"int"
					}
				}
			}

			/**
			 * CTerrorPlayer::Fling(Vector const&, PlayerAnimEvent_t, CBaseCombatCharacter*, float)
			 *
			 * Note: Detouring as a pre-hook for blocking Charger flings per player before survivors are flung.
			 * Note: Detouring as a pre-hook for shortening recovery time per player before survivors are flung.
			 **/
			"MTDetour_CTerrorPlayer::Fling"
			{
				"signature"	"CTerrorPlayer::Fling"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"velocity"
					{
						"type"		"vectorptr"
					}
					"animation"
					{
						"type"		"int"
					}
					"charger"
					{
						"type"		"cbaseentity"
					}
					"viewDuration"
					{
						"type"		"float"
					}
				}
			}

			/**
			 * CTerrorPlayer::OnHitByVomitJar(CBaseCombatCharacter*)
			 *
			 * Note: Detouring as a pre-hook for blocking bile bomb effects before players are affected.
			 * Note: Detouring as a pre-hook for providing a forward for other plugins to use.
			 **/
			"MTDetour_CTerrorPlayer::OnHitByVomitJar"
			{
				"signature"	"CTerrorPlayer::OnHitByVomitJar"
				"callconv"	"thiscall"
				"return"	"void"
				"this"		"entity"
				"arguments"
				{
					"thrower"
					{
						"type"		"cbaseentity"
					}
				}
			}

			/**
			 * CTerrorPlayer::SelectWeightedSequence(Activity)
			 *
			 * Note: Detouring as a post-hook for accelerating Tank taunting animations after incapacitating a survivor.
			 **/
			"MTDetour_CTerrorPlayer::SelectWeightedSequence"
			{
				"signature"	"CTerrorPlayer::SelectWeightedSequence"
				"callconv"	"thiscall"
				"return"	"int"
				"this"		"entity"
				"arguments"
				{
					"activity"
					{
						"type"		"int"
					}
				}
			}

			/**
			 * CTerrorWeapon::CanDeployFor(CTerrorPlayer*)
			 *
			 * Note: Detouring as a pre-hook for patching move type per player while on ladders.
			 * Note: Detouring as a post-hook for removing patch for move type while on ladders.
			 * Note: L4D2 has one param.
			 **/
			"MTDetour_CTerrorWeapon::CanDeployFor"
			{
				"arguments"
				{
					"player"
					{
						"type"		"cbaseentity"
					}
				}
			}
		}

		"Addresses"
		{
			/**
			 * Windows: Uses an offset of "CDirectorMusicBanks::OnRoundStart" to get the Director's address.
			 * Linux: Uses a symbol pointing to the Director's address.
			 **/
			"CDirector"
			{
				"linux"
				{
					"signature"	"TheDirector"
				}
				"windows"
				{
					"signature"	"CDirectorMusicBanks::OnRoundStart"
					"offset"	"12"
				}
			}

			/**
			 * This is the failsafe method for finding the default jump height (57.0) by jumping to its location.
			 * If the "DoJumpValueBytes" method fails, the plugin will rely on this method instead.
			 **/
			"DoJumpValueRead"
			{
				"signature"	"CTerrorGameMovement::DoJump"
				"linux"
				{
					"offset"	"671"
				}
				"windows"
				{
					"offset"	"86"
				}
			}
		}

		"Offsets"
		{
			/**
			 * CBaseBackpackItem::GetUseAction()
			 *
			 * How to find:
			 * 1. Use asherkin's VTable dump.
			 **/
			"CBaseBackpackItem::GetUseAction"
			{
				"linux"		"453"
				"windows"	"451"
			}

			/**
			 * CBaseCombatWeapon::GetMaxClip1()
			 *
			 * How to find:
			 * 1. Use asherkin's VTable dump.
			 **/
			"CBaseCombatWeapon::GetMaxClip1"
			{
				"linux"		"324"
				"windows"	"323"
			}

			/**
			 * CBaseEntity::IsInStasis()
			 *
			 * How to find:
			 * 1. Use asherkin's VTable dump.
			 **/
			"CBaseEntity::IsInStasis"
			{
				"linux"		"40"
				"windows"	"39"
			}

			/**
			 * CTankClaw::GroundPound()
			 *
			 * Note: Patches the "HasPlayerControlledZombies" check.
			 *
			 * How to find on Windows:
			 * 1. Look in the "CTankClaw::GroundPound" function for a variable that stores the return value of "HasPlayerControlledZombies".
			 * 2. Look for a condition that validates that variable.
			 * 3. Verify that it starts with "74" and is 2 bytes long.
			 * 4. Verify that the next line starts with "80" and is 4 bytes long.
			 * 5. Verify that the next line starts with "74" and is 2 bytes long.
			 *
			 * How to find on Linux:
			 * 1. Look in the "CTankClaw::GroundPound" function for a variable that stores the return value of "HasPlayerControlledZombies".
			 * 2. Look for a condition that validates that variable.
			 * 3. Verify that it starts with "0F" and is 6 bytes long.
			 **/
			"CTankClaw::GroundPound::Check"
			{
				"linux"		"988" // start at 0F and patch 2 bytes with NOP (0x90) and an unconditional jump (0xE9) to skip instruction
				"windows"	"923" // start at 74 and patch 8 bytes with NOPs (0x90)
			}

			/**
			 * CTankClaw::SweepFist(Vector const&, Vector const&)
			 *
			 * Note: Patches the "HasPlayerControlledZombies" check.
			 *
			 * How to find:
			 * 1. Look in the "CTankClaw::SweepFist" function for a condition that validates "HasPlayerControlledZombies" or "IsSurvivalMode".
			 * 2. Verify that it starts with "E8" and is 5 bytes long.
			 * 3. The instruction should look like a function call.
			 **/
			"CTankClaw::SweepFist::Check1"
			{
				"linux"		"2554" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"1382" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTankClaw::SweepFist(Vector const&, Vector const&)
			 *
			 * Note: Patches the "IsSurvivalMode" check.
			 *
			 * How to find:
			 * 1. Look in the "CTankClaw::SweepFist" function for a condition that validates "HasPlayerControlledZombies" or "IsSurvivalMode".
			 * 2. Verify that it starts with "E8" and is 5 bytes long.
			 * 3. The instruction should look like a function call.
			 **/
			"CTankClaw::SweepFist::Check2"
			{
				"linux"		"3488" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"1391" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTankRock::OnRelease(Vector const&, QAngle const&, Vector const&, Vector const&)
			 *
			 * Note: Patches the "CBaseEntity::EmitSound" call for "HulkZombie.Throw.FlyLoop".
			 *
			 * How to find on Windows:
			 * 1. Locate the "HulkZombie.Throw.FlyLoop" string.
			 * 2. The instruction should look like a function call.
			 * 3. Look for the 2-byte float (FLDZ) instruction right before a PUSH instruction above that function call.
			 * 4. The length of the JMP instruction patch will be determined by the following equation:
			 * Let a1 = Address of the patch location + five bytes (because the patch itself takes five bytes)
			 * Let a2 = Address of the start of the setup for the "CBaseEntity::ThinkSet" call
			 * Equation: a2 - a1 = JMP instruction length
			 *
			 * How to find on Linux:
			 * 1. Locate the "HulkZombie.Throw.FlyLoop" string.
			 * 2. The instruction should look like a function call.
			 **/
			"CTankRock::OnRelease::SoundLoop"
			{
				"linux"		"203" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"122" // start at D9 and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
			}

			/**
			 * CTerrorGun::EquipSecondWeapon()
			 *
			 * Note: Patches the "CTerrorGun::Deploy" function call.
			 *
			 * How to find:
			 * 1. Look for the fourth "CBaseCombatCharacter::GetActiveWeapon" function call.
			 * 2. The call instruction below that should be the start of the "CTerrorGun::Holster" function call.
			 * 3. The call instruction below that should be the start of the "CBaseCombatCharacter::SetActiveWeapon" function call.
			 * 4. The call instruction below that should be the start of the "CTerrorGun::Deploy" function call.
			 * Let a1 = Address of the patch location + five bytes (because the patch itself takes five bytes)
			 * Let a2 = Address of the start of the instruction after the "CTerrorGun::Deploy" call instruction
			 * Equation: a2 - a1 = JMP instruction length
			 **/
			"CTerrorGun::EquipSecondWeapon::Deploy"
			{
				"linux"		"325" // start at 8B and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
				"windows"	"392" // start at 8B and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
			}

			/**
			 * CTerrorGun::EquipSecondWeapon()
			 *
			 * Note: Patches the "CTerrorGun::Holster" function call.
			 *
			 * How to find:
			 * 1. Look for the fourth "CBaseCombatCharacter::GetActiveWeapon" function call.
			 * 2. The call instruction below that should be the start of the "CTerrorGun::Holster" function call.
			 * Let a1 = Address of the patch location + five bytes (because the patch itself takes five bytes)
			 * Let a2 = Address of the start of the instruction after the "CTerrorGun::Holster" call instruction
			 * Equation: a2 - a1 = JMP instruction length
			 **/
			"CTerrorGun::EquipSecondWeapon::Holster"
			{
				"linux"		"294" // start at 8B and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
				"windows"	"370" // start at 8B and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
			}

			/**
			 * CTerrorGun::EquipSecondWeapon()
			 *
			 * Note: Patches the "CBaseCombatCharacter::SetActiveWeapon" function call.
			 *
			 * How to find:
			 * 1. Look for the fourth "CBaseCombatCharacter::GetActiveWeapon" function call.
			 * 2. The call instruction below that should be the start of the "CTerrorGun::Holster" function call.
			 * 3. The call instruction below that should be the start of the "CBaseCombatCharacter::SetActiveWeapon" function call.
			 * Let a1 = Address of the patch location + five bytes (because the patch itself takes five bytes)
			 * Let a2 = Address of the start of the instruction after the "CBaseCombatCharacter::SetActiveWeapon" call instruction
			 * Equation: a2 - a1 = JMP instruction length
			 **/
			"CTerrorGun::EquipSecondWeapon::SetActiveWeapon"
			{
				"linux"		"313" // start at 89 and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
				"windows"	"384" // start at 56 and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
			}

			/**
			 * CTerrorPlayer::Deafen(float, float, float)
			 *
			 * How to find:
			 * 1. Use asherkin's VTable dump.
			 **/
			"CTerrorPlayer::Deafen"
			{
				"linux"		"518"
				"windows"	"517"
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: This is the offset for the "m_hAttacker" member variable in the "CTakeDamageInfo" class.
			 *
			 * How to find:
			 * 1. Look in the alliedmodders/hl2sdk-l4d2 "takedamageinfo.h" file.
			 * 2. Each member variable takes up 4 bytes for each of its cells (12 bytes for floats).
			 **/
			"CTerrorPlayer::Event_Killed::Attacker"
			{
				"linux"		"52"
				"windows"	"52"
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "DispatchParticleEffect" call for "boomer_explode".
			 *
			 * How to find:
			 * 1. Locate the "boomer_explode" string.
			 * 2. There should be two references to the string.
			 * 3. This patch will be for the first reference.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Boomer1" // "boomer_explode"
			{
				"linux"		"10925" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"7411" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "CBaseEntity::EmitSound" call for "BoomerZombie.Detonate".
			 *
			 * How to find:
			 * 1. Locate the "BoomerZombie.Detonate" string.
			 * 2. There should be two references to the string.
			 * 3. This patch will be for the first reference.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Boomer2" // "BoomerZombie.Detonate"
			{
				"linux"		"10957" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"7434" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "CreateExplosion" call.
			 *
			 * How to find:
			 * 1. Locate the "BoomerZombie.Detonate" string.
			 * 2. There should be two references to the string.
			 * 3. This patch will use the first reference.
			 * 4. The function is the second function call after the string reference.
			 * 5. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Boomer3" // CreateExplosion
			{
				"linux"		"8228" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"7749" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "DispatchParticleEffect" call for "boomer_explode".
			 *
			 * How to find:
			 * 1. Locate the "boomer_explode" string.
			 * 2. There should be two references to the string.
			 * 3. This patch will be for the second reference.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Boomer4" // "boomer_explode"
			{
				"linux"		"6353" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"7603" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "CBaseEntity::EmitSound" call for "BoomerZombie.Detonate".
			 *
			 * How to find:
			 * 1. Locate the "BoomerZombie.Detonate" string.
			 * 2. There should be two references to the string.
			 * 3. This patch will be for the second reference.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Boomer5" // "BoomerZombie.Detonate"
			{
				"linux"		"6385" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"7626" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "CreateExplosion" call.
			 *
			 * How to find:
			 * 1. Locate the "boomer_exploded" string.
			 * 2. The function is located in the previous code block above that function call.
			 * 3. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Boomer6" // CreateExplosion
			{
				"linux"		"6543" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"7905" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "CBaseEntity::EmitSound" call for "SmokerZombie.Explode".
			 * Note for Windows users: The server crashes when patching 5 bytes with NOPs (0x90), so do a jump (JMP) instruction instead.
			 *
			 * How to find:
			 * 1. Locate the "SmokerZombie.Explode" string.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Smoker1" // "SmokerZombie.Explode"
			{
				"linux"		"10263" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"8174" // start at D9 and patch 2 bytes with EB ??
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "DispatchParticleEffect" call for "smoker_smokecloud".
			 *
			 * How to find:
			 * 1. Locate the "smoker_smokecloud" string.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Smoker2" // "smoker_smokecloud"
			{
				"linux"		"10419" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"8266" // start at 8B and patch 2 bytes with EB ??
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "DispatchParticleEffect" call for "smoker_smokecloud_camera".
			 *
			 * How to find:
			 * 1. Locate the "smoker_smokecloud_camera" string.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::Event_Killed::Smoker3" // "smoker_smokecloud_camera"
			{
				"linux"		"10611" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"8480" // start at E8 and patch 5 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "CTerrorPlayer::Event_Killed" function to skip a large portion of the Spitter death logic.
			 *
			 * How to find:
			 * 1. Locate the "insect_swarm" string.
			 * 2. Scroll up until you reach the if statement that checks for the Spitter class (4).
			 * 3a. (Windows) The patch location should be a MOV instruction two lines before a 2-byte CALL instruction.
			 * 3b. (Linux) The patch location should be a MOV instruction three lines before a 6-byte CALL instruction.
			 * 4. The length of the JMP instruction patch will be determined by the following equation:
			 * Let a1 = Address of the patch location + five bytes (because the patch itself takes five bytes)
			 * Let a2 = Address of the start of the setup for the "CBaseEntity::EmitSound" call for "SpitterZombie.Death"
			 * Equation: a2 - a1 = JMP instruction length
			 **/
			"CTerrorPlayer::Event_Killed::SpitterPuddle" // JMP instruction
			{
				"linux"		"12526" // start at 8B and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
				"windows"	"9332" // start at 8B and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
			}

			/**
			 * CTerrorPlayer::GetFlowDistance(CNavArea const*)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 * 5. Look for the 7-byte float (FLD) instruction.
			 * 6. The offset at the very end of that line of code is the offset for "m_flow".
			 *
			 * How to find on Linux:
			 * 1. Locate the function.
			 * 2. Look for the 9-byte move (MOVSS) instruction.
			 * 3. The offset at the very end of that line of code is the offset for "m_flow".
			 **/
			"CTerrorPlayer::GetFlowDistance::m_flow"
			{
				"linux"		"340"
				"windows"	"332"
			}

			/**
			 * CTerrorPlayer::GetLastKnownArea()
			 *
			 * How to find:
			 * 1. Use asherkin's VTable dump.
			 **/
			"CTerrorPlayer::GetLastKnownArea"
			{
				"linux"		"331"
				"windows"	"330"
			}

			/**
			 * CTerrorPlayer::OnFalling()
			 *
			 * Note: Patches the "CBaseEntity::EmitTrackedSound" call for "Player.Fall".
			 *
			 * How to find on Windows:
			 * 1. Locate the "Player.Fall" string.
			 * 2. The instruction should look like a function call.
			 * 3. Look for the 6-byte float (FLD) instruction right before a PUSH instruction above that function call.
			 * 4. The length of the JMP instruction patch will be determined by the following equation:
			 * Let a1 = Address of the patch location + five bytes (because the patch itself takes five bytes)
			 * Let a2 = Address of the start of the setup for the 2-byte JMP instruction
			 * Equation: a2 - a1 = JMP instruction length
			 *
			 * How to find on Linux:
			 * 1. Locate the "Player.Fall" string.
			 * 2. The instruction should look like a function call.
			 **/
			"CTerrorPlayer::OnFalling::Scream"
			{
				"linux"		"678" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"552" // start at D9 and patch 5 bytes with an unconditional jump (0xE9) to skip instruction
			}

			/**
			 * CTerrorPlayer::OnIncapacitatedAsSurvivor(CTakeDamageInfo const&)
			 *
			 * How to find on Windows:
			 * 1. Search for the "PlayerIncapacitated" string to locate the "CTerrorPlayer::OnIncapacitatedAsSurvivor" function.
			 * 2. Look for the "weapon_pistol" string which should be a few lines above the "PainLevel:Critical" string.
			 * 3. There are two function calls above the line where "weapon_pistol" is referenced.
			 * 4. The variable that is being assigned a value below those two function calls has an offset.
			 * 5. The offset will be the offset for the hidden melee weapon.
			 *
			 * How to find on Linux:
			 * 1. Locate the function.
			 * 2. Look for the "weapon_pistol" string which should be a few lines above the "PainLevel:Critical" string.
			 * 3. There are two function calls above the line where "weapon_pistol" is referenced.
			 * 4. The variable that is being assigned a value below those two function calls has an offset.
			 * 5. Multiply the offset by 4 to get the offset for the hidden melee weapon.
			 **/
			"CTerrorPlayer::OnIncapacitatedAsSurvivor::HiddenMeleeWeapon"
			{
				"linux"		"16288"
				"windows"	"16308"
			}

			/**
			 * CTerrorPlayer::OnLadderDismount()
			 *
			 * Note: Patches weapon deploy logic.
			 *
			 * How to find:
			 * 1. Locate the second call to "CBaseCombatCharacter::GetActiveWeapon".
			 * 2. The patch location is at the line of code below that function call.
			 **/
			"CTerrorPlayer::OnLadderDismount::WeaponDeploy"
			{
				"linux"		"68" // start at 8B and patch 11 bytes with NOPs (0x90)
				"windows"	"49" // start at FF and patch 2 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::OnLadderMount()
			 *
			 * Note: Patches weapon holster logic.
			 *
			 * How to find:
			 * 1. Look for the team check.
			 * 2. The patch location should be a jump (JZ/JNZ) instruction.
			 **/
			"CTerrorPlayer::OnLadderMount::WeaponHolster"
			{
				"linux"		"68" // start at 75 and patch 2 bytes with NOPs (0x90)
				"windows"	"47" // start at 74 and patch 2 bytes with POP (0x5E) and RET (0xC3)
			}

			/**
			 * CTerrorPlayer::OnTakeDamage_Alive(CTakeDamageInfo const&)
			 *
			 * Note: Patches the "CTerrorPlayer::StopBeingRevived" function call.
			 *
			 * How to find on Windows:
			 * 1. Find a 2-byte instruction that pushes a "1" to a function call.
			 * 2. The function call that the "1" is being passed to is the patch location.
			 *
			 * How to find on Linux:
			 * 1. Find an 8-byte instruction that moves a bool value to a function call.
			 * 2. The function call that the bool value is being passed to is the patch location.
			 **/
			"CTerrorPlayer::OnTakeDamage_Alive::Revive"
			{
				"linux"		"3217" // start at E8 and patch 5 bytes with NOPs (0x90)
				"windows"	"2387" // start at 6A and patch 9 bytes with NOPs (0x90)
			}

			/**
			 * CTerrorPlayer::PreThink()
			 *
			 * Note: Patches the safe drop logic.
			 *
			 * How to find:
			 * 1. Look for a compare (CMP) instruction that compares a value to "9".
			 * 2. Get the offset of the last byte.
			 **/
			"CTerrorPlayer::PreThink::SafeDropLogic"
			{
				"linux"		"181" // start at 09 and patch 1 byte with CALL (0xFF)
				"windows"	"498" // start at 09 and patch 1 byte with CALL (0xFF)
			}

			/**
			 * CTerrorPlayer::RoundRespawn()
			 *
			 * Note: Patches the stats reset function.
			 *
			 * How to find:
			 * 1. Look for a jump (JNZ) instruction.
			 * 2. That is the patch location.
			 **/
			"CTerrorPlayer::RoundRespawn::StatsCondition"
			{
				"linux"		"25" // start at 75 and patch 1 byte with JNS (0x79)
				"windows"	"15" // start at 75 and patch 1 byte with JNS (0x79)
			}

			/**
			 * CTerrorWeapon::CanDeploy()
			 *
			 * Note: Patches the move type logic.
			 *
			 * How to find:
			 * 1. Look for a compare (CMP) instruction that compares a value to "9".
			 * 2. Get the offset of the last byte.
			 **/
			"CTerrorWeapon::CanDeployFor::MoveType"
			{
				"linux"		"76" // start at 09 and patch 1 byte with CALL (0xFF)
				"windows"	"87" // start at 09 and patch 1 byte with CALL (0xFF)
			}

			/**
			 * Tank::GetIntentionInterface()
			 *
			 * How to find:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2a. Use IDA to get the VTable dump for the "Tank" class on Windows.
			 * 2b. Use IDA to get the VTable dump for the "Tank" class on Linux.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4a. Look for the target function in the Windows binary.
			 * 4b. Look for the target function in the Linux binary.
			 * 5. Multiply the member variable offset by 4.
			 **/
			"Tank::GetIntentionInterface"
			{
				"linux"		"17176"
				"windows"	"17204"
			}

			/**
			 * TankIdle::GetName()
			 *
			 * How to find:
			 * 1. Use asherkin's VTable dump.
			 **/
			"TankIdle::GetName"
			{
				"linux"		"41"
				"windows"	"40"
			}

			/**
			 * WitchLocomotion::IsAreaTraversable(CNavArea const*)
			 *
			 * How to find:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2a. Use IDA to get the VTable dump for the "WitchLocomotion" class on Windows.
			 * 2b. Use IDA to get the VTable dump for the "WitchLocomotion" class on Linux.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4a. Look for the target function in the Windows binary.
			 * 4b. Look for the target function in the Linux binary.
			 * 5. Look for the first 10-byte TEST instruction.
			 * 6. The offset in that instruction is the offset for "m_attributeFlags".
			 **/
			"WitchLocomotion::IsAreaTraversable::m_attributeFlags"
			{
				"linux"		"300"
				"windows"	"296"
			}
		}

		"Signatures"
		{
			/**
			 * CAmmoDef::MaxCarry(int, CBaseCombatCharacter const*)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CAmmoDef" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CAmmoDef::MaxCarry"
			{
				"library"	"server"
				"linux"		"@_ZN8CAmmoDef8MaxCarryEiPK20CBaseCombatCharacter"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x7C\x2A\x3B\x2A\x2A\x7D\x2A\x6B\x2A\x2A\x03\x2A\x8B\x2A\x2A\x83\x2A\x2A\x75\x2A\x8B\x2A\x2A\x85\x2A\x74\x2A\x8B\x2A\x2A\x8B\x2A\x2A\x5D"
						/* ? ? ? ? ? ? 83 ? ? 7C ? 3B ? ? 7D ? 6B ? ? 03 ? 8B ? ? 83 ? ? 75 ? 8B ? ? 85 ? 74 ? 8B ? ? 8B ? ? 5D */
			}

			/**
			 * CBaseBackpackItem::StartAction(CBaseBackpackItem::BackpackItemActionType, CBaseBackpackItem::BackpackItemActionTrigger)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CBaseBackpackItem" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CBaseBackpackItem::StartAction"
			{
				"library"	"server"
				"linux"		"@_ZN17CBaseBackpackItem11StartActionENS_22BackpackItemActionTypeENS_25BackpackItemActionTriggerE"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x75\x2A\x5F\x32\x2A\x5E\x8B"
						/* ? ? ? ? ? ? 8B ? E8 ? ? ? ? 8B ? 85 ? 75 ? 5F 32 ? 5E 8B */
			}

			/**
			 * CBaseCombatWeapon::GetMaxClip1()
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CBaseCombatWeapon" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CBaseCombatWeapon::GetMaxClip1"
			{
				"library"	"server"
				"linux"		"@_ZNK17CBaseCombatWeapon11GetMaxClip1Ev"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x50\xE8\x2A\x2A\x2A\x2A\x8B\x80\x60\x01"
						/* ? ? ? ? ? ? ? 50 E8 ? ? ? ? 8B 80 60 01 */
			}

			/**
			 * CDeathFallCamera::Enable(CBasePlayer*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "SurvivorStandingOnCar" string.
			 * 2. The string can only be found in "CTerrorPlayer::OnGroundChanged".
			 * 3. Look for the "point_deathfall_camera" string in "CTerrorPlayer::OnGroundChanged".
			 * 4. The first function call after that string's second reference should be "CBasePlayer::ClearZoomOwner".
			 * 5. One of the functions that calls "CBasePlayer::ClearZoomOwner" should be this function.
			 **/
			"CDeathFallCamera::Enable"
			{
				"library"	"server"
				"linux"		"@_ZN16CDeathFallCamera6EnableEP11CBasePlayer"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x57\x8B\x2A\x8B\x2A\x89\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x85"
						/* ? ? ? ? ? ? ? ? 57 8B ? 8B ? 89 ? ? E8 ? ? ? ? 85 */
			}

			/**
			 * CDirector::HasAnySurvivorLeftSafeArea()
			 *
			 * How to find on Windows:
			 * 1. Search for the "I've walked out of the checkpoint" string.
			 * 2. The first function call below the string should be this function.
			 **/
			"CDirector::HasAnySurvivorLeftSafeArea"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector26HasAnySurvivorLeftSafeAreaEv"
				"windows"	"\x8A\x2A\xA0\x00\x00\x00\xC3"
						/* 8A ? A0 00 00 00 C3 */
			}

			/**
			 * CDirector::IsFirstMapInScenario()
			 *
			 * How to find on Windows:
			 * 1. Search for the "Game/chapter" string.
			 * 2. One of the functions that references that string is referenced by this function.
			 * 3. This function should contain a "map" string.
			 **/
			"CDirector::IsFirstMapInScenario"
			{
				"library"	"server"
				"linux"		"@_ZNK9CDirector20IsFirstMapInScenarioEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x56\x8B\x2A\x85\x2A\x75\x2A\xBE\x2A\x2A\x2A\x2A\x6A"
						/* ? ? ? ? ? ? ? ? 56 8B ? 85 ? 75 ? BE ? ? ? ? 6A */
			}

			/**
			 * CDirector::OnFirstSurvivorLeftSafeArea(CTerrorPlayer*)
			 *
			 * How to find on Windows:
			 * 1a. Search for the "Allowing spawning - %s left safe area\n" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CDirector" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CDirector::OnFirstSurvivorLeftSafeArea"
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector27OnFirstSurvivorLeftSafeAreaEP13CTerrorPlayer"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x8B\x2A\x2A\x57\x8B\x2A\x8B\x8F\x2A\x2A\x2A\x2A\x53"
						/* ? ? ? ? ? ? 53 8B ? ? 57 8B ? 8B 8F ? ? ? ? 53 */
			}

			/**
			 * CDirectorMusicBanks::OnRoundStart()
			 *
			 * Note: This is only used for the "CDirector" address on Windows.
			 *
			 * How to find:
			 * 1a. Search for the "Event.Reveal" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CDirectorMusicBanks" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 ***/
			"CDirectorMusicBanks::OnRoundStart"
			{
				"library"	"server"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x57\x8B\x2A\x8B\x0D\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x0F"
						/* ? ? ? ? ? ? 56 57 8B ? 8B 0D ? ? ? ? E8 ? ? ? ? 84 ? 0F */
			}

			/**
			 * CEnvRockLauncher::LaunchCurrentDir()
			 *
			 * How to find on Windows:
			 * 1. Search for the "tank_rock" string.
			 * 2. One of the functions that references that string is "CTankRock::Create".
			 * 3. One of the functions that calls "CTankRock::Create" should be this function.
			 **/
			"CEnvRockLauncher::LaunchCurrentDir"
			{
				"library"	"server"
				"linux"		"@_ZN16CEnvRockLauncher16LaunchCurrentDirEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x8B\x2A\x8B\x86\x2A\x2A\x2A\x2A\xC1\x2A\x2A\x57\xA8\x2A\x74\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x8E\x2A\x2A\x2A\x2A\x8B\x96\x2A\x2A\x2A\x2A\x8B\x86\x2A\x2A\x2A\x2A\x89\x2A\x2A\x8B\x8E\x2A\x2A\x2A\x2A\xC1\x2A\x2A\x89\x2A\x2A\x89\x2A\x2A\xF6\x2A\x2A\x74\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x96\x2A\x2A\x2A\x2A\x8B\x86\x2A\x2A\x2A\x2A\x8B\x8E\x2A\x2A\x2A\x2A\x6A\x2A\x89\x2A\x2A\x68\x2A\x2A\x2A\x2A\x8D\x2A\x2A\x89\x2A\x2A\x52\x8D\x2A\x2A\x50\x89\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x8E\x2A\x2A\x2A\x2A\x8B\x2A\x8D"
						/* ? ? ? ? ? ? 56 8B ? 8B 86 ? ? ? ? C1 ? ? 57 A8 ? 74 ? E8 ? ? ? ? 8B 8E ? ? ? ? 8B 96 ? ? ? ? 8B 86 ? ? ? ? 89 ? ? 8B 8E ? ? ? ? C1 ? ? 89 ? ? 89 ? ? F6 ? ? 74 ? 8B ? E8 ? ? ? ? 8B 96 ? ? ? ? 8B 86 ? ? ? ? 8B 8E ? ? ? ? 6A ? 89 ? ? 68 ? ? ? ? 8D ? ? 89 ? ? 52 8D ? ? 50 89 ? ? E8 ? ? ? ? 8B 8E ? ? ? ? 8B ? 8D */
			}

			/**
			 * CFirstAidKit::OnActionComplete(CTerrorPlayer*, CBaseEntity*)
			 *
			 * How to find on Windows:
			 * 1a. Search for the "RelaxedSigh" or "HealedByFriend" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CFirstAidKit" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CFirstAidKit::OnActionComplete"
			{
				"library"	"server"
				"linux"		"@_ZN12CFirstAidKit16OnActionCompleteEP13CTerrorPlayerP11CBaseEntity"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x57\x8B\x2A\x2A\x85\x2A\x74\x2A\x8B\x2A\x8B\x90"
						/* ? ? ? ? ? ? 53 56 57 8B ? ? 85 ? 74 ? 8B ? 8B 90 */
			}

			/**
			 * CSmokeCloudSystem::FireGameEvent(IGameEvent *)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CSmokeCloudSystem" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CSmokeCloudSystem::FireGameEvent"
			{
				"library"	"server" // change 55 to C3
				"linux"		"@_ZN17CSmokeCloudSystem13FireGameEventEP10IGameEvent"
				"windows"	"\x55\x8B\x2A\x83\x2A\x2A\x56\x8B\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x57\x8B\x2A\x8B\x2A\xFF\x2A\x3D\x2A\x2A\x2A\x2A\x74\x2A\x68\x2A\x2A\x2A\x2A\x50\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x85\x2A\x0F\x85\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x6A\x2A\x68\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x50\xE8\x2A\x2A\x2A\x2A\x8B"
						/* 55 8B ? 83 ? ? 56 8B ? ? 8B ? 8B ? ? 57 8B ? 8B ? FF ? 3D ? ? ? ? 74 ? 68 ? ? ? ? 50 E8 ? ? ? ? 83 ? ? 85 ? 0F 85 ? ? ? ? 8B ? 8B ? ? 6A ? 68 ? ? ? ? 8B ? FF ? 50 E8 ? ? ? ? 8B */
			}

			/**
			 * CSpitterProjectile::Create(Vector const&, QAngle const&, Vector const&, Vector const&, CBaseCombatCharacter*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "Spitter projectile spawned at %f %f %f, velocity %f %f %f\n" string.
			 * 2. The string can only be found in this function.
			 **/
			"CSpitterProjectile::Create"
			{
				"library"	"server"
				"linux"		"@_ZN18CSpitterProjectile6CreateERK6VectorRK6QAngleS2_S2_P20CBaseCombatCharacter"
				"windows"	"\x55\x8B\x2A\x8B\x2A\x2A\x8B\x2A\x2A\x53\x8B\x2A\x2A\x56\x57\x50\x51\x53\x68\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x2A\xD9\x2A\x2A\x83\x2A\x2A\xDD\x2A\x2A\x2A\x8B\x2A\xD9\x2A\x2A\xDD\x2A\x2A\x2A\xD9\x2A\xDD\x2A\x2A\x2A\xD9\x2A\x2A\xDD\x2A\x2A\x2A\xD9\x2A\x2A\xDD\x2A\x2A\x2A\xD9\x2A\xDD\x2A\x2A\x68\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\xD9\x05\x2A\x2A\x2A\x2A\x83\x2A\x2A\x8B\x2A\xD9\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x57"
						/* 55 8B ? 8B ? ? 8B ? ? 53 8B ? ? 56 57 50 51 53 68 ? ? ? ? E8 ? ? ? ? 8B ? ? D9 ? ? 83 ? ? DD ? ? ? 8B ? D9 ? ? DD ? ? ? D9 ? DD ? ? ? D9 ? ? DD ? ? ? D9 ? ? DD ? ? ? D9 ? DD ? ? 68 ? ? ? ? E8 ? ? ? ? D9 05 ? ? ? ? 83 ? ? 8B ? D9 ? ? E8 ? ? ? ? 57 8B ? E8 ? ? ? ? 57 8B ? E8 ? ? ? ? 8B ? ? 57 */
			}

			/**
			 * CTankClaw::DoSwing()
			 *
			 * How to find on Windows:
			 * 1a. Search for any of the following strings (they can each only be found in this function):
			 * - "rhand"
			 * - "lhand"
			 * - "ValveBiped.Bip01_L_Hand"
			 * 1b. Search for the "ValveBiped.Bip01_R_Hand" string.
			 * 2b. One of the functions that references that string should be this function.
			 **/
			"CTankClaw::DoSwing"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankClaw7DoSwingEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x89\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x85"
						/* ? ? ? ? ? ? 56 89 ? ? E8 ? ? ? ? 8B ? 85 */
			}

			/**
			 * CTankClaw::GroundPound()
			 *
			 * How to find on Windows:
			 * 1. Locate the "CTankClaw::SweepFist" function.
			 * 2. Click on the second to last function call to go to "CTerrorWeapon::MarkAsHit".
			 * 3. This function calls "CTerrorWeapon::MarkAsHit" twice.
			 * 4. To pinpoint the right function, look for the one that sets multiple variables to "0".
			 **/
			"CTankClaw::GroundPound"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankClaw11GroundPoundEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x81\xEC\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x56\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x89"
						/* ? ? ? ? ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 81 EC ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 56 57 8B ? E8 ? ? ? ? 8B ? 89 */
			}

			/**
			 * CTankClaw::OnPlayerHit(CTerrorPlayer*, bool)
			 *
			 * How to find on Windows:
			 * 1a. Search for the "PlayerGroundPoundedByTank" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTankClaw" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTankClaw::OnPlayerHit"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankClaw11OnPlayerHitEP13CTerrorPlayerb"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53\x56\x8B\x2A\x2A\x57\x8B\x2A\x89\x2A\x2A\xE8"
						/* ? ? ? ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 53 56 8B ? ? 57 8B ? 89 ? ? E8 */
			}

			/**
			 * CTankClaw::SweepFist(Vector const&, Vector const&)
			 *
			 * How to find on Windows:
			 * 1. Locate the "CTankClaw::DoSwing" function.
			 * 2. The last function call should be this function.
			 **/
			"CTankClaw::SweepFist"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankClaw9SweepFistERK6VectorS2_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x81\xEC\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x8B\x2A\x2A\x56\x57\x8B\x2A\x2A\x89\x8D"
						/* ? ? ? ? ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 81 EC ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 8B ? ? 56 57 8B ? ? 89 8D */
			}

			/**
			 * CTankRock::Create(Vector const&, QAngle const&, Vector const&, CBaseCombatCharacter*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "tank_rock" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTankRock::Create"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankRock6CreateERK6VectorRK6QAngleS2_P20CBaseCombatCharacter"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x53\x8B\x2A\x2A\x56\x57\x53\x50"
						/* ? ? ? ? ? ? 8B ? ? 53 8B ? ? 56 57 53 50 */
			}

			/**
			 * CTankRock::Detonate()
			 *
			 * How to find on Windows:
			 * 1a. Search for the "tank_rock_throw_impact_stump" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTankRock" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTankRock::Detonate"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankRock8DetonateEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x8B\x2A\x80\xBE\x2A\x2A\x2A\x2A\x2A\x57\x0F\x84\x2A\x2A\x2A\x2A\xA1"
						/* ? ? ? ? ? ? 53 56 8B ? 80 BE ? ? ? ? ? 57 0F 84 ? ? ? ? A1 */
			}

			/**
			 * CTankRock::OnRelease(Vector const&,QAngle const&,Vector const&,Vector const&)
			 *
			 * How to find on Windows:
			 * 1. Search for the "HulkZombie.Throw.FlyLoop" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTankRock::OnRelease"
			{
				"library"	"server"
				"linux"		"@_ZN9CTankRock9OnReleaseERK6VectorRK6QAngleS2_S2_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x57\xC6\x86\x2A\x2A\x2A\x2A\x2A\xC7"
						/* ? ? ? ? ? ? 57 C6 86 ? ? ? ? ? C7 */
			}

			/**
			 * CTerrorGameMovement::DoJump(Vector*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "player_jump" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorGameMovement::DoJump"
			{
				"library"	"server"
				"linux"		"@_ZN19CTerrorGameMovement6DoJumpEP6Vector"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x8B\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x57\x6A\x2A\xFF\x2A\x8B\x8E\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x6A\x2A\x6A"
						/* ? ? ? ? ? ? 56 8B ? 8B ? 8B 90 ? ? ? ? 57 6A ? FF ? 8B 8E ? ? ? ? 8B ? 8B 90 ? ? ? ? 6A ? 6A */
			}

			/**
			 * CTerrorGameMovement::DoJump(Vector*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "57.0" value in the "CTerrorGameMovement::DoJump" function.
			 * 2. Go to the instruction for that line in the code.
			 * 3. Double-click the offset that represents that value to get the address.
			 **/
			"CTerrorGameMovement::DoJump::Value"
			{
				"library"	"server"
				"linux"		"\x00\x00\x00\x00\x00\x80\x4C\x40"
				"windows"	"\x00\x00\x00\x00\x00\x80\x4C\x40"
			}

			/**
			 * CTerrorGameRules::GetMissionFirstMap(KeyValues**)
			 *
			 * How to find on Windows:
			 * 1. Search for the "Game/chapter" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorGameRules::GetMissionFirstMap"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules18GetMissionFirstMapEPP9KeyValues"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x85\x2A\x74\x2A\xC7\x07\x2A\x2A\x2A\x2A\x8B\x0D\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\xFF\x2A\x8B\x2A\x8B\x2A\x8B\x2A\x2A\x6A\x2A\xFF\x2A\x8B\x2A\x85\x2A\x75\x2A\x5F\x5E\x5D\xC3\x8B\x0D\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x57\x56\xFF\x2A\x6A\x2A\x68\x2A\x2A\x2A\x2A\x8B\x2A\x8B"
						/* ? ? ? ? ? ? ? ? 85 ? 74 ? C7 07 ? ? ? ? 8B 0D ? ? ? ? 8B ? 8B ? ? FF ? 8B ? 8B ? 8B ? ? 6A ? FF ? 8B ? 85 ? 75 ? 5F 5E 5D C3 8B 0D ? ? ? ? 8B ? 8B ? ? 57 56 FF ? 6A ? 68 ? ? ? ? 8B ? 8B */
			}

			/**
			 * CTerrorGameRules::GetMissionInfo()
			 *
			 * How to find on Windows:
			 * 1. Search for the "L4D2C" string.
			 * 2. Both functions that reference the string call this function.
			 **/
			"CTerrorGameRules::GetMissionInfo"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules14GetMissionInfoEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x56\xFF\x2A\x8B\x2A\x8B\x2A\x8B\x2A\x2A\x6A\x2A\xFF\x2A\x8B\x2A\x85\x2A\x75\x2A\x5E"
						/* ? ? ? ? ? ? ? ? ? ? 8B ? 8B ? ? 56 FF ? 8B ? 8B ? 8B ? ? 6A ? FF ? 8B ? 85 ? 75 ? 5E */
			}

			/**
			 * CTerrorGameRules::HasConfigurableDifficultySetting()
			 *
			 * How to find on Windows:
			 * 1. Search for the "hasdifficulty" string.
			 * 2. The string can only be found in this function.
			 **/
			"CTerrorGameRules::HasConfigurableDifficultySetting"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules32HasConfigurableDifficultySettingEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x85\x2A\x75\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x75\x2A\xE8"
						/* ? ? ? ? ? ? 85 ? 75 ? E8 ? ? ? ? 84 ? 75 ? E8 */
			}

			/**
			 * CTerrorGameRules::IsGenericCooperativeMode()
			 *
			 * How to find on Windows:
			 * 1. Search for the "realism" string.
			 * 2. One of the functions that references that string should be "CTerrorGameRules::IsRealismMode".
			 * 3. One of the functions that calls "CTerrorGameRules::IsRealismMode" should be this function.
			 **/
			"CTerrorGameRules::IsGenericCooperativeMode"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules24IsGenericCooperativeModeEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x75\x2A\xE8\x2A\x2A\x2A\x2A\x84\xC0\x75\x2A\x33\xC0\xC3\xB8\x01\x00\x00\x00\xC3\xCC\xCC\xCC\xCC\xCC\x8B"
						/* ? ? ? ? ? ? ? 75 ? E8 ? ? ? ? 84 C0 75 ? 33 C0 C3 B8 01 00 00 00 C3 CC CC CC CC CC 8B */
			}

			/**
			 * CTerrorGameRules::IsMissionFinalMap()
			 *
			 * How to find on Windows:
			 * 1. Search for the "Game/chapter" string.
			 * 2. One of the functions that references that string should be this function.
			 * 3. This function references the string twice.
			 **/
			"CTerrorGameRules::IsMissionFinalMap"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules17IsMissionFinalMapEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x2A\x56\xFF\x2A\x8B\x2A\x8B\x2A\x8B\x2A\x2A\x6A\x2A\xFF\x2A\x8B\x2A\x85\x2A\x75\x2A\xB0"
						/* ? ? ? ? ? ? 8B ? 8B ? ? 56 FF ? 8B ? 8B ? 8B ? ? 6A ? FF ? 8B ? 85 ? 75 ? B0 */
			}

			/**
			 * CTerrorGameRules::IsScavengeMode()
			 *
			 * How to find on Windows:
			 * 1. Search for the "scavenge" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorGameRules::IsScavengeMode"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules14IsScavengeModeEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x85\x2A\x75\x2A\x32\x2A\xC3\xF7\x05\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x74\x2A\xB8\x10\x2A\x2A\x2A\xEB\x2A\xA1\xC4\x2A\x2A\x2A\x8B\x2A\x2A\x85\x2A\x75\x2A\xB8\x64\x2A\x2A\x2A\x8B\x2A\x50\x8B\x2A\x2A\xFF\x2A\x85\x2A\x74\x2A\x68\x30"
						/* ? ? ? ? ? ? 85 ? 75 ? 32 ? C3 F7 05 ? ? ? ? ? ? ? ? 74 ? B8 10 ? ? ? EB ? A1 C4 ? ? ? 8B ? ? 85 ? 75 ? B8 64 ? ? ? 8B ? 50 8B ? ? FF ? 85 ? 74 ? 68 30 */
			}

			/**
			 * CTerrorGameRules::IsSurvivalMode()
			 *
			 * How to find on Windows:
			 * 1. Search for the "survival" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorGameRules::IsSurvivalMode"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules14IsSurvivalModeEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x85\x2A\x75\x2A\x32\x2A\xC3\xF7\x05\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x74\x2A\xB8\x10\x2A\x2A\x2A\xEB\x2A\xA1\xC4\x2A\x2A\x2A\x8B\x2A\x2A\x85\x2A\x75\x2A\xB8\x64\x2A\x2A\x2A\x8B\x2A\x50\x8B\x2A\x2A\xFF\x2A\x85\x2A\x74\x2A\x68\x50"
						/* ? ? ? ? ? ? 85 ? 75 ? 32 ? C3 F7 05 ? ? ? ? ? ? ? ? 74 ? B8 10 ? ? ? EB ? A1 C4 ? ? ? 8B ? ? 85 ? 75 ? B8 64 ? ? ? 8B ? 50 8B ? ? FF ? 85 ? 74 ? 68 50 */
			}

			/**
			 * CTerrorGameRules::IsVersusMode()
			 *
			 * How to find on Windows:
			 * 1. Search for the "teamversus" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorGameRules::IsVersusMode"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules12IsVersusModeEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x85\x2A\x75\x2A\x32\x2A\xC3\xF7\x05\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x74\x2A\xB8\x10\x2A\x2A\x2A\xEB\x2A\xA1\xC4\x2A\x2A\x2A\x8B\x2A\x2A\x85\x2A\x75\x2A\xB8\x64\x2A\x2A\x2A\x8B\x2A\x50\x8B\x2A\x2A\xFF\x2A\x85\x2A\x74\x2A\x68\x48"
						/* ? ? ? ? ? ? 85 ? 75 ? 32 ? C3 F7 05 ? ? ? ? ? ? ? ? 74 ? B8 10 ? ? ? EB ? A1 C4 ? ? ? 8B ? ? 85 ? 75 ? B8 64 ? ? ? 8B ? 50 8B ? ? FF ? 85 ? 74 ? 68 48 */
			}

			/**
			 * CTerrorGun::EquipSecondWeapon()
			 *
			 * How to find on Windows:
			 * 1a. Search for the "Player.PickupWeapon" string.
			 * 2a. One of the functions that references that string should be this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTerrorGun" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTerrorGun::EquipSecondWeapon"
			{
				"library"	"server"
				"linux"		"@_ZN10CTerrorGun17EquipSecondWeaponEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x8B\x2A\x80\xBE\x2A\x2A\x2A\x2A\x2A\x74\x2A\x32\x2A\x5E\x8B"
						/* ? ? ? ? ? ? 56 8B ? 80 BE ? ? ? ? ? 74 ? 32 ? 5E 8B */
			}

			/**
			 * CTerrorGun::FireBullet()
			 *
			 * How to find on Windows:
			 * 1. Search for any of the following strings (they can each only be found in this function):
			 * - "CTerrorGun::FireBullet HorizSpread"
			 * - "CTerrorGun::FireBullet VertSpread"
			 * - "m_iClip1 <= 0"
			 * - "IsFirePreventedUntilButtonRelease"
			 * - "IsHoldingFireButton() && !IsFullyAutomatic()"
			 **/
			"CTerrorGun::FireBullet"
			{
				"library"	"server"
				"linux"		"@_ZN10CTerrorGun10FireBulletEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x80"
						/* ? ? ? ? ? ? 53 56 8B ? E8 ? ? ? ? 8B ? 85 ? 0F 84 ? ? ? ? 80 */
			}

			/**
			 * CTerrorGun::Use(CBaseEntity *, CBaseEntity *, USE_TYPE, float)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorGun" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CTerrorGun::Use"
			{
				"library"	"server"
				"linux"		"@_ZN10CTerrorGun3UseEP11CBaseEntityS1_8USE_TYPEf"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x57\x8B\x2A\x2A\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x8B"
						/* ? ? ? ? ? ? 56 57 8B ? ? 8B ? 85 ? 0F 84 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 84 ? 0F 84 ? ? ? ? 8B ? 8B */
			}

			/**
			 * CTerrorMeleeWeapon::SecondaryAttack()
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorMeleeWeapon" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CTerrorMeleeWeapon::SecondaryAttack"
			{
				"library"	"server"
				"linux"		"@_ZN18CTerrorMeleeWeapon15SecondaryAttackEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x0F"
						/* ? ? ? ? ? ? ? ? ? 8B ? 85 ? 0F 84 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 84 ? 0F 84 ? ? ? ? 8B ? E8 ? ? ? ? 84 ? 0F */
			}

			/**
			 * CTerrorMeleeWeapon::TestMeleeSwingCollision(Vector const&)
			 *
			 * How to find on Windows:
			 * 1. Search for any of the following strings:
			 * - "MeleeSlashSplatter"
			 * - "MeleeClubSplatter"
			 * - "CollectClosestCommonInfectedScan()"
			 * - "bloodslash"
			 * 2. One of the functions that references any of these strings should be this function.
			 **/
			"CTerrorMeleeWeapon::TestMeleeSwingCollision"
			{
				"library"	"server"
				"linux"		"@_ZN18CTerrorMeleeWeapon23TestMeleeSwingCollisionERK6Vector"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x81\xEC\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x56\x8B\x2A\x2A\x57\x89\x2A\x2A\xE8"
						/* ? ? ? ? ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 81 EC ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 56 8B ? ? 57 89 ? ? E8 */
			}

			/**
			 * CTerrorPlayer::DoAnimationEvent(PlayerAnimEvent_t, int)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::DoAnimationEvent"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer16DoAnimationEventE17PlayerAnimEvent_ti"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x57\x8B\x2A\x83\x2A\x2A\x74\x2A\x8B\x8F"
						/* ? ? ? ? ? ? ? 57 8B ? 83 ? ? 74 ? 8B 8F */
			}

			/**
			 * CTerrorPlayer::Event_Killed(CTakeDamageInfo const&)
			 *
			 * How to find on Windows:
			 * 1a. Search for any of the following strings (they can each only be found in this function):
			 * - "charger_carry_kill"
			 * - "blood_bleedout"
			 * - "spitter_killed"
			 * - "SubjectIsA:%s,Distance:%f"
			 * - "DeadCharacter:"
			 * - ",SubjectTeam:Survivor"
			 * - "SurvivorDied"
			 * - "pounce_attempt_stopped"
			 * - "infected_explosive_barrel_kill"
			 * - "mulletTongue"
			 * - "charger_killed"
			 * - "charging"
			 * - "jockey_killed"
			 * - "boomer_exploded"
			 * - "splashedbile"
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::Event_Killed"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer12Event_KilledERK15CTakeDamageInfo"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x81\xEC\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x8B\x2A\x2A\x56\x8B\x2A\x8B\x2A\x89\x85\x2A\x2A\x2A\x2A\x8B\x82\x2A\x2A\x2A\x2A\x57\xFF\x2A\x8B\x2A\x8B"
						/* ? ? ? ? ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 81 EC ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 8B ? ? 56 8B ? 8B ? 89 85 ? ? ? ? 8B 82 ? ? ? ? 57 FF ? 8B ? 8B */
			}

			/**
			 * CTerrorPlayer::Fling(Vector const&, PlayerAnimEvent_t, CBaseCombatCharacter*, float)
			 *
			 * How to find on Windows:
			 * 1. Search for the "charger_impact" string.
			 * 2. The string can only be found in "ThrowImpactedSurvivor".
			 * 3. The function call before the line where that string is referenced should be this function.
			 **/
			"CTerrorPlayer::Fling"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer5FlingERK6Vector17PlayerAnimEvent_tP20CBaseCombatCharacterf"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x81\xEC\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x8B\x2A\x2A\x56\x8B\x2A\x2A\x57\x6A"
						/* ? ? ? ? ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 81 EC ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 8B ? ? 56 8B ? ? 57 6A */
			}

			/**
			 * CTerrorPlayer::GoAwayFromKeyboard()
			 *
			 * How to find on Windows:
			 * 1. Search for the "player_afk" string.
			 * 2. The string can only be found in this function.
			 **/
			"CTerrorPlayer::GoAwayFromKeyboard"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer18GoAwayFromKeyboardEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x57\x8B\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B"
						/* ? ? ? ? ? ? 53 56 57 8B ? 8B ? 8B 90 ? ? ? ? 8B */
			}

			/**
			 * CTerrorPlayer::MaterializeFromGhost()
			 *
			 * How to find on Windows:
			 * 1. Search for the "%s materialized from spawn mode as a %s\n" string.
			 * 2. The string can only be found in this function.
			 **/
			"CTerrorPlayer::MaterializeFromGhost"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer20MaterializeFromGhostEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xFF\x2A\x50\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x50\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x50\x68\x2A\x2A\x2A\x2A\xE8"
						/* ? ? ? ? ? ? ? ? ? ? ? FF ? 50 E8 ? ? ? ? 83 ? ? 50 8B ? 8B 90 ? ? ? ? 8B ? FF ? 50 68 ? ? ? ? E8 */
			}

			/**
			 * CTerrorPlayer::OnBeginChangeLevel(char const*)
			 *
			 * How to find on Windows:
			 * 1a. Search for the "Saving %s for transition at %f %f %f\n" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::OnBeginChangeLevel"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer18OnBeginChangeLevelEPKc"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x0F\x85\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F\x85\x2A\x2A\x2A\x2A\x53"
						/* ? ? ? ? ? ? ? E8 ? ? ? ? 84 ? 0F 85 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 84 ? 0F 85 ? ? ? ? 53 */
			}

			/**
			 * CTerrorPlayer::OnEnterGhostState()
			 *
			 * How to find on Windows:
			 * 1a. Search for the "spawnmode_bar" string.
			 * 2a. One of the functions that references that string should be this function.
			 * 3a. This function should also contain "data" and "zombieClass" strings.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::OnEnterGhostState"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer17OnEnterGhostStateEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x8B\x2A\x8B\x86\x2A\x2A\x2A\x2A\x8B\x2A\x2A\x8D\x8E\x2A\x2A\x2A\x2A\x57"
						/* ? ? ? ? ? ? 53 56 8B ? 8B 86 ? ? ? ? 8B ? ? 8D 8E ? ? ? ? 57 */
			}

			/**
			 * CTerrorPlayer::OnFalling()
			 *
			 * How to find on Windows:
			 * 1. Search for the "PlayerZombie.Fall" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorPlayer::OnFalling"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer9OnFallingEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53\x56\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x0F"
						/* ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 53 56 57 8B ? E8 ? ? ? ? 83 ? ? 0F */
			}

			/**
			 * CTerrorPlayer::OnHitByVomitJar(CBaseCombatCharacter*)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::OnHitByVomitJar"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer15OnHitByVomitJarEP20CBaseCombatCharacter"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x74\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F"
						/* ? ? ? ? ? ? 56 8B ? E8 ? ? ? ? 84 ? 74 ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 84 ? 0F */
			}

			/**
			 * CTerrorPlayer::OnIncapacitatedAsTank(CTakeDamageInfo const&)
			 *
			 * How to find on Windows:
			 * 1. Search for the "deathEvent" or "HulkZombie.Die" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorPlayer::OnIncapacitatedAsTank"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer21OnIncapacitatedAsTankERK15CTakeDamageInfo"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x8E\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x50\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x74"
						/* ? ? ? ? ? ? ? 8B 8E ? ? ? ? E8 ? ? ? ? 50 8B ? E8 ? ? ? ? 84 ? 74 */
			}

			/**
			 * CTerrorPlayer::OnITExpired()
			 *
			 * How to find on Windows:
			 * 1. Search for the "PlayerVomitExpired" string.
			 * 2. The string can only be found in this function.
			 **/
			"CTerrorPlayer::OnITExpired"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer11OnITExpiredEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x0F\x2E\x2A\x2A\x2A\x2A\x2A\x8D\xB7\x2A\x2A\x2A\x2A\x9F\xF6\x2A\x2A\x7B\x2A\x8B\x2A\x2A\x8B\x2A\x8D\x2A\x2A\x56\xFF\x2A\xF3\x0F\x2A\x2A\x2A\x2A\x2A\x2A\xF3\x2A\x2A\x2A\x8B\x2A\x6A"
						/* ? ? ? ? ? ? ? ? ? ? ? ? 0F 2E ? ? ? ? ? 8D B7 ? ? ? ? 9F F6 ? ? 7B ? 8B ? ? 8B ? 8D ? ? 56 FF ? F3 0F ? ? ? ? ? ? F3 ? ? ? 8B ? 6A */
			}

			/**
			 * CTerrorPlayer::OnLadderDismount()
			 *
			 * How to find on Windows:
			 * 1. Search for the "CTerrorPlayer::PlayerRunCommand" string.
			 * 2. The string can only be found in "CTerrorPlayer::PlayerRunCommand".
			 * 3. The last function call in "CTerrorPlayer::PlayerRunCommand" should be this function.
			 **/
			"CTerrorPlayer::OnLadderDismount"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer16OnLadderDismountEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x50\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x84\x2A\x74\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x85\x2A\x74\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x2A\x8B\x82\x2A\x2A\x2A\x2A\xFF"
						/* ? ? ? ? ? ? ? ? 50 E8 ? ? ? ? 83 ? ? 84 ? 74 ? 8B ? E8 ? ? ? ? 85 ? 74 ? 8B ? E8 ? ? ? ? 8B ? 8B ? 8B 82 ? ? ? ? FF */
			}

			/**
			 * CTerrorPlayer::OnLadderMount()
			 *
			 * How to find on Windows:
			 * 1. Search for the "Player.Fall" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorPlayer::OnLadderMount"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer13OnLadderMountEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x6A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x50"
						/* ? ? ? ? ? ? 8B ? E8 ? ? ? ? 8B ? E8 ? ? ? ? 6A ? 8B ? E8 ? ? ? ? 8B ? E8 ? ? ? ? 50 */
			}

			/**
			 * CTerrorPlayer::OnRevived()
			 *
			 * How to find on Windows:
			 * 1a. Search for the "ReviveType" or "RevivedByFriend" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::OnRevived"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer9OnRevivedEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x8B\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x57\xFF\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\xE8"
						/* ? ? ? ? ? ? 53 56 8B ? 8B ? 8B 90 ? ? ? ? 57 FF ? 84 ? 0F 84 ? ? ? ? 8B ? E8 */
			}

			/**
			 * CTerrorPlayer::OnShovedByPounceLanding(CTerrorPlayer*, bool)
			 *
			 * How to find on Windows:
			 * 1. Search for the "Tongue letting go on getting bashed." string.
			 * 2. The string can only be found in "CTerrorPlayer::OnStunned".
			 * 3. One of the functions that calls "CTerrorPlayer::OnStunned" should be this function.
			 **/
			"CTerrorPlayer::OnShovedByPounceLanding"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer23OnShovedByPounceLandingEPS_b"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x56\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x0F\x85\x2A\x2A\x2A\x2A\x57"
						/* ? ? ? ? ? ? 56 8B ? E8 ? ? ? ? 84 ? 0F 85 ? ? ? ? 57 */
			}

			/**
			 * CTerrorPlayer::OnShovedBySurvivor(CTerrorPlayer*, Vector const&)
			 *
			 * How to find on Windows:
			 * 1. Search for the "Survivor was lunged while %sfacing the hunter and %sbashing\n" string.
			 * 2. The string can only be found in one function.
			 * 3. The very last function call in the code block that comes after the line where that string is referenced should be this function.
			 **/
			"CTerrorPlayer::OnShovedBySurvivor"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer18OnShovedBySurvivorEPS_RK6Vector"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53\x8B\x2A\x2A\x56\x57\x8B\x2A\x2A\x8B\x2A\x89"
						/* ? ? ? ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 53 8B ? ? 56 57 8B ? ? 8B ? 89 */
			}

			/**
			 * CTerrorPlayer::OnStaggered(CBaseEntity*, Vector const*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "PlayerShoved" string.
			 * 2. One of the functions that references that string should be this function.
			 **/
			"CTerrorPlayer::OnStaggered"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer11OnStaggeredEP11CBaseEntityPK6Vector"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x83\x2A\x2A\x83\x2A\x2A\x55\x8B\x2A\x2A\x89\x2A\x2A\x2A\x8B\x2A\x83\x2A\x2A\x56\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x0F\x85\x2A\x2A\x2A\x2A\x8B\x2A\x8B"
						/* ? ? ? ? ? ? 83 ? ? 83 ? ? 55 8B ? ? 89 ? ? ? 8B ? 83 ? ? 56 57 8B ? E8 ? ? ? ? 84 ? 0F 85 ? ? ? ? 8B ? 8B */
			}

			/**
			 * CTerrorPlayer::OnTakeDamage_Alive(CTakeDamageInfo const&)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::OnTakeDamage_Alive"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer18OnTakeDamage_AliveERK15CTakeDamageInfo"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x53\x8B\x2A\x2A\x56\x8B\x2A\x8B\x2A\x2A\x57\x83\x2A\x2A\x74"
						/* ? ? ? ? ? ? ? ? ? 53 8B ? ? 56 8B ? 8B ? ? 57 83 ? ? 74 */
			}

			/**
			 * CTerrorPlayer::OnVomitedUpon(CTerrorPlayer*, bool)
			 *
			 * How to find on Windows:
			 * 1. Search for the "PlayerVomitInFace" string.
			 * 2. The string can only be found in this function.
			 **/
			"CTerrorPlayer::OnVomitedUpon"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer13OnVomitedUponEPS_b"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x74\x2A\x8B\x2A\x8B"
						/* ? ? ? ? ? ? 53 56 57 8B ? E8 ? ? ? ? 84 ? 74 ? 8B ? 8B */
			}

			/**
			 * CTerrorPlayer::PreThink()
			 *
			 * How to find on Windows:
			 * 1a. Search for the "#L4D_idle_spectator" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::PreThink"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer8PreThinkEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x56\x57\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\xE8"
						/* ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 56 57 8B ? E8 ? ? ? ? 8B ? E8 */
			}

			/**
			 * CTerrorPlayer::RoundRespawn()
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::RoundRespawn"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer12RoundRespawnEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x84\x2A\x75\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\xC6\x86"
						/* ? ? ? ? ? ? ? ? E8 ? ? ? ? 84 ? 75 ? 8B ? E8 ? ? ? ? C6 86 */
			}

			/**
			 * CTerrorPlayer::SelectWeightedSequence(Activity)
			 *
			 * How to find on Windows:
			 * 1a. Search for the "Hulk_RunAttack1_Gesture" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. Use IDA to get the VTable dump for the "CTerrorPlayer" class on Windows.
			 * 3b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4b. Look for the target function in the Windows binary.
			 **/
			"CTerrorPlayer::SelectWeightedSequence"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer22SelectWeightedSequenceE8Activity"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x81\xFF\x2A\x2A\x2A\x2A\x75"
						/* ? ? ? ? ? ? ? ? 8B ? 81 FF ? ? ? ? 75 */
			}

			/**
			 * CTerrorPlayer::StartReviving(CTerrorPlayer*)
			 *
			 * How to find on Windows:
			 * 1. Search for any of the following strings (they can each only be found in this function):
			 * - "Tongue letting because victim is being revived"
			 * - "%s starts reviving %s"
			 * - "revive_begin"
			 * - "PlayerHeal"
			 * - "PlayerLedgeSaveCritical"
			 * - "PlayerReviveFriendCritical"
			 * - "PlayerLedgeSave"
			 * - "PlayerReviveFriend"
			 **/
			"CTerrorPlayer::StartReviving"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorPlayer13StartRevivingEPS_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53\x8B\x2A\x2A\x8B\x83\x2A\x2A\x2A\x2A\x56"
						/* ? ? ? ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 53 8B ? ? 8B 83 ? ? ? ? 56 */
			}

			/**
			 * CTerrorWeapon::CanDeployFor(CTerrorPlayer*)
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorWeapon" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CTerrorWeapon::CanDeployFor"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorWeapon12CanDeployForEP13CTerrorPlayer"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x57\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\xE8"
						/* ? ? ? ? ? ? ? 57 8B ? 85 ? 0F 84 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 8B ? E8 */
			}

			/**
			 * CTerrorWeapon::SecondaryAttack()
			 *
			 * How to find on Windows:
			 * 1. Find the function's offsets with asherkin's VTable dump.
			 * 2. Use IDA to get the VTable dump for the "CTerrorWeapon" class on Windows.
			 * 3. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 4. Look for the target function in the Windows binary.
			 **/
			"CTerrorWeapon::SecondaryAttack"
			{
				"library"	"server"
				"linux"		"@_ZN13CTerrorWeapon15SecondaryAttackEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F\x85\x2A\x2A\x2A\x2A\x8B\x2A\x8B"
						/* ? ? ? ? ? ? ? ? ? 8B ? 85 ? 0F 84 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 84 ? 0F 84 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 84 ? 0F 85 ? ? ? ? 8B ? 8B */
			}

			/**
			 * CWeaponSpawn::Use(CBaseEntity *, CBaseEntity *, USE_TYPE, float)
			 *
			 * How to find on Windows:
			 * 1a. Search for the "spawner_give_item" string.
			 * 2a. The string can only be found in this function.
			 *
			 * 1b. Find the function's offsets with asherkin's VTable dump.
			 * 2b. In IDA Pro, go to the ".rdata" section of the Windows binary.
			 * 3b. Search for "CWeaponSpawn::`vftable'" to jump to the "CWeaponSpawn" vtable.
			 * 4b. Compare your dump's offsets with asherkin's dump's offsets to find the target function.
			 * 5b. Look for the target function in the Windows binary.
			 **/
			"CWeaponSpawn::Use"
			{
				"library"	"server"
				"linux"		"@_ZN12CWeaponSpawn3UseEP11CBaseEntityS1_8USE_TYPEf"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x57\x8B\x2A\x2A\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B"
						/* ? ? ? ? ? ? 53 57 8B ? ? 8B ? 85 ? 0F 84 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 84 ? 0F 84 ? ? ? ? 8B */
			}

			/**
			 * KeyValues::GetString(char const*, char const*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "L4D2C" string.
			 * 2. Both functions that reference the string call this function.
			 **/
			"KeyValues::GetString"
			{
				"library"	"server"
				"linux"		"@_ZN9KeyValues9GetStringEPKcS1_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\xA1\x2A\x2A\x2A\x2A\x33\x2A\x89\x2A\x2A\x53\x8B\x2A\x2A\x56\x57\x6A\x2A\x53\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x8B\x2A\x85\x2A\x0F\x84\x2A\x2A\x2A\x2A\x0F\x2A\x2A\x2A\x48\x83\x2A\x2A\x0F\x87\x2A\x2A\x2A\x2A\xFF\x24\x2A\x2A\x2A\x2A\x2A\xD9\x2A\x2A\x83\x2A\x2A\xDD\x2A\x2A\x68"
						/* ? ? ? ? ? ? ? ? ? A1 ? ? ? ? 33 ? 89 ? ? 53 8B ? ? 56 57 6A ? 53 8B ? E8 ? ? ? ? 8B ? 85 ? 0F 84 ? ? ? ? 0F ? ? ? 48 83 ? ? 0F 87 ? ? ? ? FF 24 ? ? ? ? ? D9 ? ? 83 ? ? DD ? ? 68 */
			}

			/**
			 * PassServerEntityFilter(IHandleEntity const*, IHandleEntity const*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "RagdollImpact" string.
			 * 2. One of the functions that references that string should be "CBaseEntity::FireBullets".
			 * 3. Click on the first function call below the string to go to "Pickup_ForcePlayerToDropThisObject".
			 * 4. Check the references for "Pickup_ForcePlayerToDropThisObject".
			 * 5. One of the functions that calls "Pickup_ForcePlayerToDropThisObject" should be "CTraceFilterMelee::ShouldHitEntity".
			 * 6. The second function call in "CTraceFilterMelee::ShouldHitEntity" should be this function.
			 **/
			"PassServerEntityFilter"
			{
				"library"	"server"
				"linux"		"@_Z22PassServerEntityFilterPK13IHandleEntityS1_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x85\x2A\x75\x2A\xB0\x2A\x5F\x5D\xC3\x56"
						/* ? ? ? ? ? ? ? 85 ? 75 ? B0 ? 5F 5D C3 56 */
			}

			/**
			 * Tank::EnterStasis()
			 *
			 * How to find on Windows:
			 * 1. Search for any of the following strings (they can each only be found in one function):
			 * - "Tank offer: Starting the lottery\n"
			 * - "Tank offer: Going to the only PZ\n"
			 * - "Tank offer: making a bot, and giving him to nobody\n"
			 * 2. This function should be referenced by a function that is two function calls above the "Tank offer: Starting the lottery\n" string.
			 * 3. This function should be the last function call in that function.
			 **/
			"Tank::EnterStasis"
			{
				"library"	"server"
				"linux"		"@_ZN4Tank11EnterStasisEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8D\xB7\x2A\x2A\x2A\x2A\x74\x2A\x8B\x86\x2A\x2A\x2A\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8D\x8E\x2A\x2A\x2A\x2A\x56\xFF\x2A\xC6\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x6A"
						/* ? ? ? ? ? ? ? ? ? ? ? 8D B7 ? ? ? ? 74 ? 8B 86 ? ? ? ? 8B 90 ? ? ? ? 8D 8E ? ? ? ? 56 FF ? C6 ? ? 8B ? 8B 90 ? ? ? ? 6A */
			}

			/**
			 * Tank::LeaveStasis()
			 *
			 * How to find on Windows:
			 * 1. Search for the "Tank committing suicide at %f %f %f\n" string.
			 * 2. There should be two function calls above the string.
			 * 2. The first function call should be this function.
			 **/
			"Tank::LeaveStasis"
			{
				"library"	"server"
				"linux"		"@_ZN4Tank11LeaveStasisEv"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x2A\x8D\xB7\x2A\x2A\x2A\x2A\x74\x2A\x8B\x86\x2A\x2A\x2A\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8D\x8E\x2A\x2A\x2A\x2A\x56\xFF\x2A\xC6\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B"
						/* ? ? ? ? ? ? ? ? ? ? ? 8D B7 ? ? ? ? 74 ? 8B 86 ? ? ? ? 8B 90 ? ? ? ? 8D 8E ? ? ? ? 56 FF ? C6 ? ? 8B ? 8B 90 ? ? ? ? 8B */
			}

			/**
			 * ZombieManager::ReplaceTank(CTerrorPlayer*, CTerrorPlayer*)
			 *
			 * How to find on Windows:
			 * 1. Search for the "TANK OFFER: Looking for players\n" string.
			 * 2. The last function call in that function should be this function.
			 **/
			"ZombieManager::ReplaceTank"
			{
				"library"	"server"
				"linux"		"@_ZN13ZombieManager11ReplaceTankEP13CTerrorPlayerS1_"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x53\x56\x8B\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x57\x8B\x2A\x8B\x2A\xFF\x2A\x84\x2A\x0F\x84\x2A\x2A\x2A\x2A\x8B\x2A\xE8\x2A\x2A\x2A\x2A\x83\x2A\x2A\x0F\x85\x2A\x2A\x2A\x2A\x8B\x2A\x8B\x90\x2A\x2A\x2A\x2A\x8B\x2A\xFF\x2A\x83"
						/* ? ? ? ? ? ? 53 56 8B ? ? 8B ? 8B 90 ? ? ? ? 57 8B ? 8B ? FF ? 84 ? 0F 84 ? ? ? ? 8B ? E8 ? ? ? ? 83 ? ? 0F 85 ? ? ? ? 8B ? 8B 90 ? ? ? ? 8B ? FF ? 83 */
			}

			/**
			 * ZombieManager::SpawnTank(Vector const&, QAngle const&)
			 *
			 * How to find on Windows:
			 * 1. Search for the "Failed to find a tank spawn position in area %d\n" string.
			 * 2. The second function call in that function should be this function.
			 **/
			"ZombieManager::SpawnTank"
			{
				"library"	"server"
				"linux"		"@_ZN13ZombieManager9SpawnTankERK6VectorRK6QAngle"
				"windows"	"\x2A\x2A\x2A\x2A\x2A\x2A\x8B\x0D\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x85\x2A\x78\x2A\x8B\x0D\x2A\x2A\x2A\x2A\x39\x81\x2A\x2A\x2A\x2A\x7C\x2A\x33\x2A\x5F"
						/* ? ? ? ? ? ? 8B 0D ? ? ? ? E8 ? ? ? ? 85 ? 78 ? 8B 0D ? ? ? ? 39 81 ? ? ? ? 7C ? 33 ? 5F */
			}
		}
	}
}